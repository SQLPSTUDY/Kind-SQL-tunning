# Week2

고정하기: No

# 5장

### Data Sort Grouping

- PGA : Program Global Area
    - 프로세스 전용 메모리로  **SGA**(System Global Area)와 달리 **공유 메모리 아님**

1. Sort Aggregate → 집계 함수 (Sort Area 사용 in PGA)
2. Sort Order by → 데이터 정렬
3. Sort Group by → 그룹핑
    - Hash Group by는 Hash 알고리즘을 사용한다.
    - 집계할 대상 Record가 아무리 많아도 Temp TableSpace를 사용 안한다.
        - Temp TableSpace란 PGA 공간이 부족할 때 사용하는 디스크
4. Sort Unique → 중복 제거(DISTINCT)
5. Sort Join → Sort Merge Join
    
    ⇒ SQL 동작 과정 중 data를 정렬하기 위해 생기는 연산? (인덱스가 있으면 정렬되야하니까)
    
6. Window Sort → 윈도우 함수

### Sort가 발생하지 않도록 SQL 작성하는법

1. 중복 제거시, Sort 연산이 발생한다. ⇒ Union All 사용해버리기
    - 단, Union All을 사용하면, 데이터에 대한 이해가 필요함 → 집합 결과가 달라질 수 있기 때문
2. 서브쿼리와 Exists 사용하기
    - Distinct 사용시, 전부 읽어야 하기 때문에 I/O 연산이 많아진다.
    - Mius도 Exists와 서브쿼리로 해결 가능하다.
    
3. 조인 방식 변경
- Sort Merge Join는 두 테이블을 조인 키 기준으로 정렬(Sort Join) 후 병합하는데
- NL 조인은 두 집합을 정렬하지 않고, 인덱스를 이용해 바로 매칭 가능

### 인덱스를 이용한 소트연산 생략

1. 종목 코드 + 거래 일시로 하면 왜 생략이 가능한가?
    - 두개를 인덱스로 하면, 데이터가 정렬되기 때문에 부분범위 처리가 가능하기 때문이다.
2. Top N
    - 부분 범위 처리를 가능하게 하는 법
        - 인덱스를 사용 가능하도록 조건절 구사(앞장에서 한듯? 선행컬럼 후행컬럼?)
        - 조인은 NL 위주
        - Order By가 있어도 인덱스 구성으로 Sort 연산을 생략할 수 있다.
            - 당연히, 인덱스에 따라 정렬되기 때문에

StopKey : 쉽게 말해 Top N 쿼리에서 옵티마이저가 특정 조건 만족하면 Scan을 멈추는 것

1. MIN/MAX ⇒ 인덱스 컬럼이라면 그냥 조회가 가능
2. 이력 조회
3. 인덱스가 있으면, 순서대로 넣어서 택배 넣어서 보낸다. 
    - 단, 인덱스 컬럼이 그룹핑 조건이어야함.

### Sort Area를 적게 사용하도록 SQL 작성

Sort 연산이 불가피하다면, 메모리 내에서 처리해야한다.

1. Sort data를 줄인다. ⇒ 출력 컬럼 제한
2. 인덱스면, 이미 정렬 되어있기 때문에, Top N + Stop Key를 사용
    - 인덱스가 없으면요?
        - Array Size
            - Page 처리에서 10개씩 출력할때, 10개의 Array Size만 준비해서 가장 초반 10개와 funll scan에서 비교한다.
            - 이는, 10개라는 한정적인 사이즈를 정하기 때문에 메모리 내에서 사용이 가능하다.
3. Top N + Stop Key가 안된다면, 테이블 스페이스 사용한다. 
4. Rank, Row_number가 Max보다 부하가 적다. 
    - Top N 이 동작하기 때문

# 6장 DML 튜닝

## 6.1

### 6.1. 1 DML 성능에 영향으 미치는 요소

1. 인덱스
    - 정렬된 자료구조이기 때문에 삽입, 삭제 시 정렬을 유지하기 위해 COST 발생
2. 무결성 제약
    - 개체 무결성 - 설명 추가
    - 참조 무결성
    - 도메인 무결성
    - 사용자 정의 무결성
    - **이러한 제약 조건이 성능에 영향을 미친다.**
3. 조건절
    - select와 유사
4. 서브쿼리
    - select와 유사
5. Redo 로깅
    - Redo 로그란?
        - DB 변경사항을 기록한 로그 (데이터 손실 및 복구 목적)
    - DML수행 시, Redo 로그를 생성하기 때문
6. Undo 로깅
    - Redo : 과거 → 현재 상태로
    - Undo : 현재 → 과거 상태로
    - Redo와 마찬가지로 로깅해야하기 때문
7. Lock
    - Lock 레벨 높을수록
    - 단, 너무 낮으면 데이터 품질이 나빠진다. (Trade-off)
8. 커밋
    - DB 버퍼캐시
    - Redo 로그버퍼
        - 변경사항 저장 (단, Redo도 I/O기 때문에 버퍼 사용)
    - 과정
        - Redo 로그버퍼에 변경사항 저장
        - 버퍼에서 읽고 없으면 데이터파일에서 Read
        - LGWR - Redo 로그버퍼 내용  일괄 저장
        - DBWR - 변경된 버퍼블록들은 데이터 파일에 저장

Q. 휘발성 로그버퍼에 기록시, 데이터를 안전하게 지키는 방법?

DBWR, LGWR는 커밋 신호 발생 및 주기적으로 깨어나 Dirty 블록과 Redo 로그버퍼를 파일에 기록한다. 

⇒ 이러면 결국 I/O가 발생하는거 아닌가? 

⇒ 그러면, I/O 시 실행중인 프로세스는 잠드는데?

GPT

LGWR가 커밋 시점에 Redo 로그 버퍼 내용을 온라인 Redo 로그 파일에 기록함
⇒ Redo 로그는 순차 I/O라 속도가 빠르다. 

DBWR이 쓰는 데이터 블록은 나중에 비동기적으로 데이터 파일에 기록된다.

### 6.1.2 데이터베이스 Call 성능

**Call의 종류**

- Parse Call -  SQL 파싱 및 최적화
- Execute Call  - 실행 (DML)
- Feth Call - Select, data많으면 여러번 발생

**위치에 따른 구분**

User Call - DBMS 외부

Recursive Call - DBMS 내부(프로시저, 트리거)

!! 절차적인 기능을 가급적 One SQL로 처리하는 것이 좋다. 

**Array Processing**을 활용해 Call 부하를 줄일 수 있다. 

⇒ **여러 건의 데이터를 “한 번에 묶어서” 데이터베이스에 보내거나 받아오는 처리 방식 ex) bulk 쿼리**

### 수정 가능 조인 뷰??

## 6.2

### 6.2.1 Direct Path I/O

버퍼 캐시가 무조건 좋은게 아니다?

- 많은 데이터가 캐시를 방문하면, 오히려 버퍼 캐시에서 블록을 찾기 힘들 수 있다.
    - 버퍼캐시의 데이터가 자주 바뀌기 때문
- 예로, full sacn한 데이터는 재사용성이 낮은 데이터들인데 버퍼 캐시를 차지하면 안되겠지?

**Direct Path I/O** 

병렬 Full scan, 병렬 DML 등에 사용

### 6.2.2 Direct Path Insert

- 테이블 HWM 아래쪽 여유 공간인 FreeList를 참조하지 않고 바깥 영역에 순차적으로 입력
- 당연히 버퍼캐시 X
- Undo X, Redo 도 안하게 할 수 있다.

⇒ 대신 여유공간을 활용하지 못하게된다. 

Q. 이렇게 할 경우, Rollback이나 이런걸 전혀 고려하지 않는건가??

롤백은 가능하지만, 데이터 안정성까지는 보장 안됨

### 6.2.3 병렬 DML

## 6.3 파티션을 활용한 DML 튜닝

### 6.3.1 테이블 파티션

Range(날짜), 해시(고객 ID처럼 변별력 + 데이터 분포 고른), 리스트(사용자가 정의한 그룹핑 기준)

### 6.3.2 인덱스 파티션

- 로컬 파티션 인덱스
    
    ```sql
    create index 주문_x01 on 주문( 주문 일자, 주문 금액) LOCAL;
    ```
    

테이블 파티션 키 == 인덱스 파티션 키

- 글로벌 파티션 인덱스
    
    테이블 ≠ 인덱스  ⇒ 서로 독립적인 구조
    
- 비파티션 인덱스

**Prefixed vs NonPrefixed**

**Prefixed :**  인덱스를 설계한 **순서대로 WHERE 절에서 사용**하는 경우 → 인덱스 잘 활용됨

**NonPrefixed:**  인덱스의 **중간 컬럼만 사용하는 경우** → 인덱스 활용도 떨어짐

**Unique 인덱스를 파티셔닝하려면, 파티션 키가 모두 인덱스 구성 컬럼이어야 한다.** 

⇒ PK 인덱스가 파티셔닝키라면 특정 파티션만 Scan하면 되지만, 인덱스 구성 컬럼이 아닌 인덱스 파티셔닝을 할 경우, 모든 파티션을 탐색해야한다. ⇒ 이는 추가적인 Lock까지 발생시킨다. 

대용량 UPDATE → 코드에서 변수 값 치환할 때 생각하면됨

대용량 DELETE → 남길 데이터 백업 후 재입력

대용량 INSERT 

→ 인덱스 지우고 재생성

→ 하지만, 실무에서 그렇게 하기 쉽지 않다. 단, 로컬 파티션이라면 파티셜 단위로 인덱스를 재생성 가능하니까 충분히 가능

서비스 중단없이 파티션을 Drop or Truncate 하기 위한 조건?

1. 파티션 키와 커팅 기준 컬림이 일치
    - 파티션 키와 커팅 기준 컬럼이 모두 ‘신청일자’
2. 파티션 단위와 커팅 주기 일치
    - 월 단위 파티션을 월 주기로 커팅
3. 모든 인덱스가 로컬 파티션 인덱스이어야함
    - 파티션 키는 ‘신청일자’, PK는 ‘신청일자 + 신청순번’
    - PK 인텍스는 지금처럼 삭제 기준(파티션 키) 컬럼이 인덱스 구성 컬럼이어야 로컬 파티셔닝 가능

## 6.4 Lock과 트랜잭션 동시성 제어

### 로우 Lock

Insert → Lock 경합은 Unique 인덱스가 있을 때 

select → MVCC → Undo로깅, copy본을 보여줌

즉, DML과 select는 경합이 일어날 수가 없다. 

### Table Lock(TM LOCK in Oracle)

테이블 전체가 아닌, flag→ 어떤 작업수행하는지 기록하고 후행 T가  작업진행여부를 결정하는 것이다.

Blocking → 후행 T가 작업진행 X

교착상태 → 서로 다른 T가 Lock 설정하려고 하는 상황

- error mesg 받은 T가 롤백을 결정해야 한다.
- **WAIT**: 잠금이 풀릴 때까지 대기
- **NOWAIT**: 잠금이 걸려 있으면 즉시 실패
- **IMMEDIATE**: 명령을 즉시 실행, 대기 없이 처리(주로 병렬/Direct Path에서 사용)
- **BATCH**: 작업을 모아 한 번에 처리해 I/O 효율 향상

### 6.4.2

비관적 락 → 동시수행 할거지?

- 후행 T가 기다림
- for update를 통해 Lock을 얻기 위해 무한정 기다리는 것을 방지한다.

낙관적 락 → 동시수행 안할거지?

Q. 다중 트랜잭션이 존재하는 DB 환경에서 공유자원에 대한 엑세스 직렬화는 필수

### 6.4.3 채번 방식

딱히 주키로 설정할만한 고유한 컬럼이 없다면? **채번**

PK 컬럼 용도로 사용하고 때로는 시스템적 일련번호 형식의 채번을 PK컬럼으로 사용하기도 한다.

1. 채번 테이블
    - 각 테이블의 채번을 구분하는 값을 PK로 두고 채번컬럼을 가지는 테이블을 만드는 곳
    - 특정 테이블에 INSERT → 특정 테이블을 가리키는 채번값에 1을 더해서 UPDATE
2. 시퀀스 오브젝트
- DB내 테이블을 접근할 때마다 채번이 1씩 자동으로 증가
- 단, 읽기만 해도 증가한다.
    - 로우 캐시 Lock
    - 시퀀스 캐시 Lock
    - SV Lock
1. MAX + 1
    - 동시성 + 성능 문제로 대규모 환경에 부적합

# 7장

### 옵티마이저 종류

**비용기반 (CBO) -cost based ?**

- 다양한 통계 정보(Data dictionary)에 있는 것을 기반으로 코스트를 계산해서 실행 계획 선택
- Mode
    - ALL_ROWS: 전체 처리속도 최적화
    - FIRST_ROWS: 최초 응답 처리속도 최적화
        - 데이터를 전부 읽을 시에, Full scan하는 ALL_ROWS 보다 느릴 수 있다. (인덱스를 사용하기 떄문)
    - **FIRST_ROWS_N : 최초 N건에 대한 처리속도 최적화**
        - 그럼 최초응답을 빠르게 하고, 나머지 데이터를 많이 읽게 된다면 ALL_ROWS처럼  Full scan으로 빠르게 할 수 있다는거임?
            - 네

**규칙기반(RBO)- rule based?**

- 정해진 규칙을 따라 실행계획 설정
- 규칙 자체가 보편타당성하지만, 현 시점 대용량 데이터에는 불리하다.

옵티마이저를 바빠서 사용한다고 생각하자, ←개발자의 역할

다시한번 SQL튜닝이란 I/O, DB call, SQL 파싱을 최소화 하는 것