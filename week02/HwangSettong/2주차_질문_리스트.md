# 2주차 질문 리스트
<br/>

## 학습 범위

<br/>

- 5장 : 소트 튜닝

- 6장 : DML 튜닝

- 7장 : SQL 옵티마이저

<br/>

## 이해 안되는 부분


<details>
  <summary>Redo/Undo 최소화 기법</summary>
    
NOLOGGING 힌트 활용 전략이 있는데 NOLOGGING 시 Redo 로그가 없어서 복구 시점에 따라 데이터의 손실 위험 존재. 때문에, NOLOGGING 작업 후 반드시 완전 백업을 수행해야 한다고 함. ← 이거에 대한 성능 저하가 더 심할 것 같은데..?
    
- 실제 운영에서 성능 저하 여부
    
  **NOLOGGING 작업과 백업을 따로 떼서 생각해야 함**
    
    | 단계 | 부하 발생 여부 | 특징 |
    | --- | --- | --- |
    | NOLOGGING 대량 INSERT | Redo 로그 없이 빠르게 처리 → 부하 ↓ | 즉시적 DML 성능 극대화 |
    | 백업 작업 (보통 별도 스케줄) | 백업 I/O와 CPU 부하 발생 | *보*통 밤/비업무시간에 수행 |

  즉, NOLOGGING 작업 시점에서는 DML 부하가 크게 줄고, 백업은 별도 시간에 수행하여 부하 분산이 가능하다.

<br/>
    
- 그래서 왜 NOLOGGING + 백업이 성능 개선인가?
    - NOLOGGING 적용하면 DML 중 디스크 I/O와 CPU 부하가 크게 줄어, 대량 데이터 적재 시간이 획기적으로 단축된다.
    - 백업 작업은 DML과 분리되어, 보통 시스템 부하가 적은 시간대에 수행하기 때문에 전체 운영 부하가 분산되고, 사용자 트랜잭션에 미치는 영향이 최소화된다.

<br/>

- 운영 팁
    - 백업은 반드시 계획적으로 수행해 NOLOGGING 후 데이터 손실 리스크를 관리
    - 즉시 복구가 필요한 OLTP 시스템에서는 NOLOGGING 신중히 사용
    - 데이터 웨어하우스·배치성 시스템에서는 NOLOGGING + 백업 조합이 매우 효과적

</details>
<br/>

## 새롭게 알게 된 부분


<details>
  <summary>5장 : 소트 튜닝</summary>

  
- **소트 수행 과정**
    - **Internal Sort**: 데이터가 메모리 내 Sort Area에서 정렬 가능할 경우 수행.
    - **External Sort**: 메모리 부족 시 디스크의 Temp 테이블스페이스에 임시 정렬 결과(Sort Runs)를 저장하고 병합하여 완성.
    
    ```sql
    소트 대상 집합을 SGA 버퍼캐시를 통해 읽어들이기 
    ↓
    PGA의 Sort Area에서 일차적으로 정렬을 시도
    ↓
    양이 많으면 Temp Talespace에 임시 세그먼트를 만들어 저장 (= Sort Run)
    ↓
    데이터를 순서에 맞게 PGA로 읽어들이기
    ```
    

<br/>

- **소트 오퍼레이션 종류**
    - Sort Aggregate: 집계 함수 수행 시 정렬은 아니지만 Sort Area를 사용.
    - Sort Order By: ORDER BY가 있으면 필요한 정렬 수행.
    - Sort Group By: GROUP BY 수행 시 정렬 필요, ORDER BY와 함께 쓰이지 않으면 결과 정렬이 보장되지 않음.

<br/>

- **인덱스 활용으로 소트 연산 생략**
    - **Sort Order By 생략**: 인덱스가 `ORDER BY` 대상 컬럼을 포함하고 선두 순서가 맞으면 정렬 없이 결과 제공 가능
    - **Top N 쿼리 (Stop-Key 최적화)**: 인덱스를 활용해 상위 N개만 빠르게 조회하며, `COUNT(STOPKEY)`로 불필요한 탐색 최소화
    - **페이징 처리 (부분범위)**: 표준 패턴을 사용하면 부분범위 처리 및 StopKey 알고리즘이 작동. BETWEEN 방식은 안티 패턴으로 전체 처리되고 성능 저하 발생.
    - **최소값/최대값 조회 최적화**: 인덱스 구조를 잘 구성하면 `First Row StopKey`를 통해 빠르게 최소/최대값 조회 가능. (조건컬럼과 MIN/MAX 대상이 인덱스에 포함돼 있어야 함)
    - **복잡 이력 조회 최적화**: 내부 가공된 컬럼을 사용하면 StopKey가 작동하지 않음→ 서브쿼리 분할 또는 `INDEX_DESC` 힌트와 `ROWNUM <= 1`을 활용해 역순 인덱스 스캔으로 최적화 가능
    - **Sort Group By 생략**: 그룹 기준 컬럼을 인덱스 선두에 두면 정렬 없이 `GROUP BY` 수행 가능

<br/>

- **정렬 최소화 전략**
    - `SELECT *`는 Sort Area 부담을 높임 → 필요한 컬럼만 선택.
    - 상위 N개만 필요하면 전체 정렬하지 말고 인덱스 스캔 + stop‑key(ROWNUM/LIMIT)로 처리
    - 쿼리 WHERE, ORDER BY, MIN/MAX 조건을 고려한 인덱스 설계로 I/O 및 메모리 절감.
    - 정렬은 메모리·디스크·CPU를 많이 먹는다. 실행계획에서 Sort관련 노드 보이면 DB가 직접 정렬하지 않도록 인덱스·Top‑N·컬럼축소 검토

</details>
<details>
  <summary>6장 : DML 튜닝</summary>
  
- **DML Call 최적화**
    - SQL 실행 시 단계 : Parse → Execute → Fetch
    - 네트워크를 경유하는 경우 User Call이 느리므로, 가능하면 하나의 sql로 처리하거나 배치처리하기.

<br/>

- **DML 성능에 영향을 주는 주요 요소**
    - **인덱스**
    - **무결성 제약(PK, FK 등)**: 제약 조건은 성능에 영향을 줌. PK/FK는 Check나 Not Null보다 더 많은 부하를 유발 ← 데이터 검증이 필요해서
    - **조건절 / 서브쿼리**: DML에도 SELECT 튜닝 원리 적용
    - **Redo와 Undo 로깅**: 모든 DML은 Redo/Undo 로그를 생성함. 특히, Undo는 일관성 보장을 위해 생략 불가. 항상 필요 (MVCC 기반).
    - **Lock**
    - **커밋 빈도**

<br/>

- **MERGE 문 활용 (UPSERT)**
    - MERGE는 편하지만 존재 여부 체크 비용, lock 경합을 일으킬 수 있으니 상황에 따라 분리(UPDATE → INSERT)하는 편이 더 낫기도 함.
    - WHEN 절이 단순회 될수록 대량 처리일수록 MERGE가 유리할 수 있음
    - 대상 키 컬럼에 Unique Index 필수
    
    → 회사 코드에 merge가 생각보다 꽤 있던데 확인해봐야지
    

<br/>

- **파티션 기반 DML 최적화**
    - 파티셔닝을 잘 쓰면 대량 삭제/적재가 특정 파티션에 한정되어 효율적
    - 일반테이블에서는 INSERT 시 해당 행이 포함된 모든 인덱스에도 키를 삽입해야함 → 대량 INSERT에서 인덱스 갱신 비용 커짐
        
        인덱스를 UNUSABLE 상태로 전환 후 INSERT하면? 모든 데이터 입력을 끝내고 한번에 인덱스를 재구성 하므로 Full Scan+Sort 방식으로 인덱스를 만들기 때문에 전체 시간 단축
        
        **파티션을 사용하면?** 대량 INSERT가 특정 파티션에만 영향을 주면, 해당 파티션의 인덱스만 UNUSABLE로 전환 → 나머지 파티션은 영향 없음.

<br/>
        

- **Lock과 트랜잭션 동시성 제어**

</details>
<details>
  <summary>7장 : SQL 옵티마이저</summary>
  
- **옵티마이저 종류와 모드**
    - **RBO (규칙 기반 옵티마이저)**: 정형화된 규칙에 따라 계획을 선택. 통계 정보 활용 부족으로 대량 데이터 처리에 부적합
    - **CBO (비용 기반 옵티마이저)**: 다양한 실행 경로 중 비용을 계산해 최적의 계획을 선택
    - **모드 종류**:
        - `ALL_ROWS` — 전체 처리 속도 최적화 목표
        - `FIRST_ROWS` — 첫 번째 응답 속도 최적화 (구식)
        - `FIRST_ROWS_N` — 앞 N행 응답 최적화 (추천)

<br/>

- **옵티마이저에 영향을 미치는 요소**
    -  SQL 문 구조
    -  인덱스 및 DB 오브젝트 (IOT, 파티션, MV 등)
    -  제약 조건
    -  정확한 통계정보
    -  힌트
    -  옵티마이저 설정 파라미터
    -  ...
      
</details>
