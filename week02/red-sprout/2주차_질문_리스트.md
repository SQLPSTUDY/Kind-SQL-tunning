# 2주차 질문 리스트

## 학습 범위
- 5장: 소트 튜닝
- 6장: DML 튜닝

## 이해 안되는 부분

<details>
  <summary>JPA에서는 어떻게 쿼리를 처리할까?</summary>



</details>

## 새롭게 알게 된 부분

<details>
  <summary>5. 소트 튜닝</summary>

### 소트 수행 과정

- 메모리 소트(In-Memory Sort) : 전체 데이터의 정렬 작업을 메모리 내에서 완료, Internal Sort
- 디스크 소트(To-Disk Sort) : 디스크 공간까지 사용, External Sort
    - 많은 서버 리소스 및 Disk I/O
    - 부분범위 처리를 불가능하게 함으로써 OLTP 환경에서 애플리케이션 성능을 저하시키는 주요인
    - 가급적 소트 피하기 → 하더라도 메모리 소트로 진행

### 소트 오퍼레이션

- Sort Aggregate
    
    ```sql
    select sum(sal), max(sal), min(sal), avg(sal) from emp;
    ```
    
    - 전체 로우를 대상으로 집계 진행시
    - Sort Area 에 그룹 함수를 위한 변수를 각각 하나씩 할당
    - 각 함수에 해당 값을 저장, `COUNT` 는 초기 1, 레코드를 만날 때마다 1씩 증가
- Sort Order By
    
    ```sql
    select * from emp order by sal desc;
    ```
    
- Sort Group By & Hash Group By
    
    ```sql
    select deptno, sum(sal), max(sal), min(sal), avg(sal)
    from emp
    group by deptno
    order by deptno;
    ```
    
    - 그룹 정렬(Sort Group By) & 해시 함수(Hash Group By)
    - `TreeMap` 과 `HashMap` 느낌
    - `Sort Group By` 가 실제 정렬된 그룹핑 결과를 의미하지 않음
        - 정렬 알고리즘이 사용될 뿐 정렬 기준을 세운 것이 아님
        - `Order By` 명시할 것
- Sort Unique
    
    ```sql
    select /*+ ordered use_nl(dept) */ from dept
    where deptno in (select /*+ unest */ deptno
    									from emp where job = 'CLERK');
    ```
    
    - Unnesting 된 서브쿼리가 1:M 중 M쪽 또는 조인 컬럼에 Unique 인덱스가 없을 경우
    - 메인 쿼리와 조인하기 전에 중복 레코드부터 제거 -> `Sort Unique`
    
    ```sql
    select job, mgr from emp where deptno = 10
    union
    select job, mgr from emp where deptno = 20;
    ```
    
    - `UNION` , `MINUS` , `INTERSECT` 와 같은 집합 연산자
    
    ```sql
    select distinct deptno from emp order by deptno;
    ```
    
    - `distinct` → order by 생략시에는 `Hash Unique`
- Sort Join
    
    ```sql
    select /*+ ordered use_merge(e) */ *
    from dept d, emp e
    where d.deptno = e.deptno;
    ```
    
    - 소트 머지 조인
- Window Sort
    
    ```sql
    select empno, ename, job, mgr, sal
    			, avg(sal) over (partition by deptno)
    from emp;
    ```
    
    - 윈도우 함수(분석 함수)

### Union vs Union All

- `UNION` 사용시 Sort Unique → 중복이 없다면 `Union All` 을 사용
- 만약 중복을 피하고 싶다면…

```sql
select 결제번호, 결제수단코드, 주문번호, 결제금액, 결제일자, 주문일자 ...
from 결제
where 결제일자 = '20180316'
UNION ALL
select 결제번호, 결제수단코드, 주문번호, 결제금액, 결제일자, 주문일자 ...
from 결제
where 주문일자 = '20180316'
and 결제일자 <> '20180316' -- 조건절 추가로 중복 피하기
```

### Exists

- 서브쿼리 데이터 존재 여부만 확인하면 되기에 데이터 전체를 읽지 않음
- `Distinct` , `Minus` → `Exists` 서브쿼리로 대부분 대체

### Sort Order By 생략

```sql
select 거래일시, 체결건수, 체결수량, 거래대금
from 종목거래
where 종목코드 = 'KR123456'
order by 거래일시
```

- 인덱스를 `종목코드 + 거래일시` 로 진행시 생략 가능

### Top N 쿼리

```sql
-- MySQL
select 거래일시, 체결건수, 체결수량, 거래대금
from 종목거래
where 종목코드 = 'KR123456'
and 거래일시 >= '20180304'
order by 거래일시
limit 10;

-- Oracle
select * from (
	select 거래일시, 체결건수, 체결수량, 거래대금
	from 종목거래
	where 종목코드 = 'KR123456'
	and 거래일시 >= '20180304'
	order by 거래일시
)
where rownum <= 10
```

- Sort Order By 대신 `COUNT(STOPKEY)`
- 조건절에 부합하는 레코드가 아무리 많아도 그 중 ROWNUM으로 지정한 만큼 진행
- 친절한 SQL 튜닝 책에서는 **Top N Stopkey 알고리즘**이라 부름

```sql
-- 페이징 처리 Template
select *
from (
	select rownum no, a.*
	from (
		/* SQL Body */
	) a
	where rownum <= (:page * 10)
)
where no >= (:page - 1) * 10 + 1
```

- 위 템플릿에서 조건절을 한번에 처리시 `STOPKEY` 발동 X → 귀찮더라도 이렇게 따로 작성하기

### 최소값/최대값 구하기

- 인덱스 사용 → MIN / MAX 함수 인자 컬럼이 모두 인덱스에 포함되어 있어야함
    - 실행계획 `FIRST ROW` : 조건을 만족하는 레코드 하나를 찾았을 때 바로 멈춤
    - 친절한 SQL 튜닝 책에서는 **First Row Stopkey 알고리즘**이라 부름
- Top N 쿼리 사용 → `ROWNUM <= 1` , **Top N Stopkey 알고리즘**

### 이력 조회

```sql
select 장비번호, 장비명, 상태코드
	, (select max(변경일자)
		from 상태변경이력
		where 장비번호 = p.장비번호) 최종변경일자
from 장비 p
where 장비구분코드 = 'A001'
```

- 스칼라 서브쿼리 부분에 **First Row Stopkey 알고리즘** 작동
- 인덱스 컬럼 가공은 피해야 함 → but, 읽어야 할 컬럼이 많아지면 복잡해짐
- `INDEX_DESC` 힌트
    - 인덱스를 역순으로 읽도록 유도, 첫번째 레코드에서 바로 멈추도록 `ROWNUM <= 1` 사용
    - 인덱스가 완벽하게 구성되어야 정상적으로 작동
- **Predicate Pushing**, **Row Limiting** 등 최근 오라클에서 지원
- 인덱스는 일부 자료(손익분기점 이전) 조회시 좋음 - **전체 조회시에는 윈도우 함수 이용하는 것이 효과적**
- 다양한 이력 패턴 확인 필요

### Sort Group By 생략

- `SORT GROUP BY **NOSORT**`
- 선두 컬럼 인덱스 적용

### 소트 데이터 줄이기

- 가공, `*` 지양하기

### Top N 쿼리의 소트 부하 경감 원리

- 대상 집합에서 Top N 의 대상만 뽑은 후 정렬
- 대상 집합이 아무리 커도 Top N 쿼리는 필요한 N을 넣을 메모리 공간이 있으면 충분
- 인덱스로 소트 연산을 생략할 수 없어 `Table Full Scan` 방식 시 `SORT ORDER BY STOPKEY` 를 사용

### Top N 쿼리가 아닐 때

- Top N 템플릿에서 `where rownum` 제외시 Top N 소트 알고리즘 발동 X

### 분석함수에서 Top N 소트

- 부하 : `max` > `rank` , `row_number` → Top N 소트 알고리즘이 작동
  
</details>

<details>
  <summary>6. DML 튜닝</summary>


  
</details>

<details>
  <summary>7. 옵티마이저 튜닝</summary>


  
</details>
