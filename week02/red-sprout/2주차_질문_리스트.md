# 2주차 질문 리스트

## 학습 범위
- 5장: 소트 튜닝
- 6장: DML 튜닝

## 이해 안되는 부분

<details>
  <summary>JPA에서는 어떻게 쿼리를 처리할까?</summary>

  

</details>

<details>
  <summary>분산 락</summary>

  

</details>

## 새롭게 알게 된 부분

<details>
  <summary>5. 소트 튜닝</summary>

### 소트 수행 과정

- 메모리 소트(In-Memory Sort) : 전체 데이터의 정렬 작업을 메모리 내에서 완료, Internal Sort
- 디스크 소트(To-Disk Sort) : 디스크 공간까지 사용, External Sort
    - 많은 서버 리소스 및 Disk I/O
    - 부분범위 처리를 불가능하게 함으로써 OLTP 환경에서 애플리케이션 성능을 저하시키는 주요인
    - 가급적 소트 피하기 → 하더라도 메모리 소트로 진행

### 소트 오퍼레이션

- Sort Aggregate
    
    ```sql
    select sum(sal), max(sal), min(sal), avg(sal) from emp;
    ```
    
    - 전체 로우를 대상으로 집계 진행시
    - Sort Area 에 그룹 함수를 위한 변수를 각각 하나씩 할당
    - 각 함수에 해당 값을 저장, `COUNT` 는 초기 1, 레코드를 만날 때마다 1씩 증가
- Sort Order By
    
    ```sql
    select * from emp order by sal desc;
    ```
    
- Sort Group By & Hash Group By
    
    ```sql
    select deptno, sum(sal), max(sal), min(sal), avg(sal)
    from emp
    group by deptno
    order by deptno;
    ```
    
    - 그룹 정렬(Sort Group By) & 해시 함수(Hash Group By)
    - `TreeMap` 과 `HashMap` 느낌
    - `Sort Group By` 가 실제 정렬된 그룹핑 결과를 의미하지 않음
        - 정렬 알고리즘이 사용될 뿐 정렬 기준을 세운 것이 아님
        - `Order By` 명시할 것
- Sort Unique
    
    ```sql
    select /*+ ordered use_nl(dept) */ from dept
    where deptno in (select /*+ unest */ deptno
    									from emp where job = 'CLERK');
    ```
    
    - Unnesting 된 서브쿼리가 1:M 중 M쪽 또는 조인 컬럼에 Unique 인덱스가 없을 경우
    - 메인 쿼리와 조인하기 전에 중복 레코드부터 제거 -> `Sort Unique`
    
    ```sql
    select job, mgr from emp where deptno = 10
    union
    select job, mgr from emp where deptno = 20;
    ```
    
    - `UNION` , `MINUS` , `INTERSECT` 와 같은 집합 연산자
    
    ```sql
    select distinct deptno from emp order by deptno;
    ```
    
    - `distinct` → order by 생략시에는 `Hash Unique`
- Sort Join
    
    ```sql
    select /*+ ordered use_merge(e) */ *
    from dept d, emp e
    where d.deptno = e.deptno;
    ```
    
    - 소트 머지 조인
- Window Sort
    
    ```sql
    select empno, ename, job, mgr, sal
    			, avg(sal) over (partition by deptno)
    from emp;
    ```
    
    - 윈도우 함수(분석 함수)

### Union vs Union All

- `UNION` 사용시 Sort Unique → 중복이 없다면 `Union All` 을 사용
- 만약 중복을 피하고 싶다면…

```sql
select 결제번호, 결제수단코드, 주문번호, 결제금액, 결제일자, 주문일자 ...
from 결제
where 결제일자 = '20180316'
UNION ALL
select 결제번호, 결제수단코드, 주문번호, 결제금액, 결제일자, 주문일자 ...
from 결제
where 주문일자 = '20180316'
and 결제일자 <> '20180316' -- 조건절 추가로 중복 피하기
```

### Exists

- 서브쿼리 데이터 존재 여부만 확인하면 되기에 데이터 전체를 읽지 않음
- `Distinct` , `Minus` → `Exists` 서브쿼리로 대부분 대체

### Sort Order By 생략

```sql
select 거래일시, 체결건수, 체결수량, 거래대금
from 종목거래
where 종목코드 = 'KR123456'
order by 거래일시
```

- 인덱스를 `종목코드 + 거래일시` 로 진행시 생략 가능

### Top N 쿼리

```sql
-- MySQL
select 거래일시, 체결건수, 체결수량, 거래대금
from 종목거래
where 종목코드 = 'KR123456'
and 거래일시 >= '20180304'
order by 거래일시
limit 10;

-- Oracle
select * from (
	select 거래일시, 체결건수, 체결수량, 거래대금
	from 종목거래
	where 종목코드 = 'KR123456'
	and 거래일시 >= '20180304'
	order by 거래일시
)
where rownum <= 10
```

- Sort Order By 대신 `COUNT(STOPKEY)`
- 조건절에 부합하는 레코드가 아무리 많아도 그 중 ROWNUM으로 지정한 만큼 진행
- 친절한 SQL 튜닝 책에서는 **Top N Stopkey 알고리즘**이라 부름

```sql
-- 페이징 처리 Template
select *
from (
	select rownum no, a.*
	from (
		/* SQL Body */
	) a
	where rownum <= (:page * 10)
)
where no >= (:page - 1) * 10 + 1
```

- 위 템플릿에서 조건절을 한번에 처리시 `STOPKEY` 발동 X → 귀찮더라도 이렇게 따로 작성하기

### 최소값/최대값 구하기

- 인덱스 사용 → MIN / MAX 함수 인자 컬럼이 모두 인덱스에 포함되어 있어야함
    - 실행계획 `FIRST ROW` : 조건을 만족하는 레코드 하나를 찾았을 때 바로 멈춤
    - 친절한 SQL 튜닝 책에서는 **First Row Stopkey 알고리즘**이라 부름
- Top N 쿼리 사용 → `ROWNUM <= 1` , **Top N Stopkey 알고리즘**

### 이력 조회

```sql
select 장비번호, 장비명, 상태코드
	, (select max(변경일자)
		from 상태변경이력
		where 장비번호 = p.장비번호) 최종변경일자
from 장비 p
where 장비구분코드 = 'A001'
```

- 스칼라 서브쿼리 부분에 **First Row Stopkey 알고리즘** 작동
- 인덱스 컬럼 가공은 피해야 함 → but, 읽어야 할 컬럼이 많아지면 복잡해짐
- `INDEX_DESC` 힌트
    - 인덱스를 역순으로 읽도록 유도, 첫번째 레코드에서 바로 멈추도록 `ROWNUM <= 1` 사용
    - 인덱스가 완벽하게 구성되어야 정상적으로 작동
- **Predicate Pushing**, **Row Limiting** 등 최근 오라클에서 지원
- 인덱스는 일부 자료(손익분기점 이전) 조회시 좋음 - **전체 조회시에는 윈도우 함수 이용하는 것이 효과적**
- 다양한 이력 패턴 확인 필요

### Sort Group By 생략

- `SORT GROUP BY **NOSORT**`
- 선두 컬럼 인덱스 적용

### 소트 데이터 줄이기

- 가공, `*` 지양하기

### Top N 쿼리의 소트 부하 경감 원리

- 대상 집합에서 Top N 의 대상만 뽑은 후 정렬
- 대상 집합이 아무리 커도 Top N 쿼리는 필요한 N을 넣을 메모리 공간이 있으면 충분
- 인덱스로 소트 연산을 생략할 수 없어 `Table Full Scan` 방식 시 `SORT ORDER BY STOPKEY` 를 사용

### Top N 쿼리가 아닐 때

- Top N 템플릿에서 `where rownum` 제외시 Top N 소트 알고리즘 발동 X

### 분석함수에서 Top N 소트

- 부하 : `max` > `rank` , `row_number` → Top N 소트 알고리즘이 작동
  
</details>

<details>
  <summary>6. DML 튜닝</summary>

### DML 성능에 영향을 미치는 요소

- 인덱스
    - 과유불급, 하나라도 줄이면 TPS 향상
- 무결성 제약
    - 개체 무결성, 참조 무결성, 도메인 무결성, 사용자 정의 무결성
    - PK, FK 제약의 오버헤드가 큼
- 조건절 & 서브쿼리
    - select 문과 비슷
- Redo 로깅
    - Oracle은 모든 변경 사항을 Redo 로그에 기록, **과거 → 현재**
    - Redo 로그 - Database Recovery, Cache Recovery, Fast Commit 에 활용
- Undo 로깅
    - 롤백, **현재 → 과거**
    - Transaction RollBack, Transaction Recovery, Read Consistency
- Lock
    - Lock 이 많음 - DML 성능 감소 / Lock 이 적음 - 데이터 품질 감소
    - 동시성 제어 필요
- 커밋
    - **DB 버퍼 캐시**
        - Dirty 블록을 모아 주기적으로 DBWR(Database Writer)이 데이터 파일에 일괄 기록
    - **Redo 로그 버퍼**
        - 버퍼에서 데이터 유실되어도 Redo 로그를 통해 복구 가능
        - 성능 문제 - Redo 로그파일에 기록하기 전에 먼저 로그버퍼에 기록
        - 나중에 LGWR(Log Writer) 프로세스가 Redo 로그파일에 일괄(Batch) 기록
    - **트랜잭션 데이터 저장 과정**
        - DML 문 실행 시 Redo 로그버퍼에 변경 사항 기록
        - 버퍼 블록에서 데이터를 변경, 못찾으면 데이터파일에서 읽는 작업부터
        - 커밋
        - LGWR 프로세스 진행
        - DBWR 프로세스 진행

### 데이터베이스 Call과 성능

- Parse Call : SQL 파싱과 최적화를 수행하는 당계
- Exeute Call : SQL을 실행하는 단계, SELECT 문은 fetch 단계를 거침
- Fetch Call : 데이터를 읽어서 사용자에게 결과 집합을 전송하는 과정, SELECT 문, 전송할 데이터가 많을 때는 Fetch Call이 여러 번 발생
- User Call(DBMS 외부, 네트워크 경유) 부하 >  Recursive Call(DBMS 내부) 부하

### 인덱스 및 제약 해제를 통한 대량 DML 튜닝

- 제약 해제 → 데이터 추가 → 제약 활성화
- 수정가능 조인 뷰
    - 다른 테이블과 조인이 필요할 때 전통적인 UPDATE 문을 사용하면 비효율 완전히 해소 불가능
    - **조인 뷰** : FROM 절에 두 개 이상 테이블을 가진 뷰
    - 1 : M (`DEPT` : `EMP`) 의 관계를 가정, 둘을 조인한 조인 뷰에 대해 UPDATE 진행
        - `DEPT` 컬럼 수정시 영향을 받지 않아야 할 다른 행들도 수정되므로 부적합
        - `EMP` 컬럼 수정시 겉으로는 문제가 없지만, 옵티마이저가 자동으로 판단은 못하기에 에러
        - `DEPT` 쪽에 PK 제약 또는 Unique 인덱스 설정 후에야 옵티마이저가 판단 가능
            - `DEPT` : 비 키-보존 테이블
            - `EMP` : 키-보존 테이블
        - **키 보존 테이블** : 조인된 결과 집합을 통해서도 중복 값 없이 Unique 하게 식별 가능한 테이블

### MERGE

```sql
merge into target t using source s on (t.id = s.id)
when matched then update
	set (t.col = s.col, ...)
when not matched then insert
	(col, ...) values
	(s.col, ...)
```

- source 테이블을 기준으로 target 테이블과 Left Outer 방식으로 조인해서 **조인에 성공하면 UPDATE, 실패하면 INSERT**
- 이미 저장된 데이터를 조건에 따라 지우는 기능도 제공
- INSERT, UPDATE를 두 번 실행해야하는 쿼리를 **단 한번만 실행할 수 있게 한다.**

### Direct Path I/O

- 성능을 높이고자 버퍼 캐시를 사용하는데, 대량 블록에 대해서는 악영향 → 곧바로 I/O 수행하기
- Direct Path I/O가 작동하는 경우
    - **병렬 쿼리로 Full Scan을 수행할 때 - `parallel` , `parallel_index` 힌트**
        
        ```sql
        select /*+ full(t) parallel(t 4) */ * from big_table t; -- 병렬도 4 지정
        
        select /*+ index_ffs(t big_table_x1) parallel_index(t big_table_x1 4) */ count(*)
        from big_table t;
        ```
        
    - **병렬 DML을 수행할 때(Direct Path Read, Direct Path Insert)**
        - `alter session enable parallel dml`
        - `/*+ enable_parallel_dml */`
        - 확인 방법 → 실행 계획에서  `PX COORDINATOR` 아래 DML 수행여부 확인
    - Temp 세그먼트 블록들을 읽고 쓸 때
    - direct 옵션을 지정하고 export를 수행할 때
    - nocache 옵션을 지정한 LOB 컬럼을 읽을 때

### Direct Path Insert

- 사용 방법
    - INSERT … SELECT 문에 append 힌트 사용 - `/*+ append_values */`
    - parallel 힌트를 이용해 병렬 모드로 INSERT
    - direct 옵션을 지정하고 SQL*Loader(sqlldr)로 데이터 적재
    - CTAS(create table … as select) 문 수행
- 빠른 이유
    - Freelist 대신 HWM 바깥부터 순차 입력
        - **Freelist** : 테이블 HWM(High-Water Mark) 아래쪽에 있는 블록 중 데이터 입력이 가능한 블록을 관리한 목록
    - 버퍼캐시 X, Undo 로깅 X
    - Redo 로깅을 안하게 가능 - `alter table t NOLOGGING` → 일반 INSERT 에서는 불가능
- 주의점
    - Exclusive 모드 TM Lock
    - 테이블 여유 공간 재활용 X

### 테이블 파티션

- range 파티션 - 범위 기반(주로 날짜)
    
    ```sql
    create table t (...)
    partition by range(날짜) (
    	partition P2025_Q1 values less than ('20250101'), 
    	...
    	partition P9999_MX values less than (MAXVALUE)	
    );
    ```
    
- 해시 파티션 - 해시값이같은 데이터를 같은 세그먼트에 저장, 사용자는 파티션 개수만 결정
    
    ```sql
    create table t (...)
    partition by hash(id) partitions 4; -- 변별력이 좋고 데이터 분포가 고른게 효과적
    ```
    
- 리스트 파티션 - 사용자 정의 그룹핑 기준
    
    ```sql
    create table t (...)
    partition by list(지역) (
    	partition P_지역1 values ('서울'), 
    	partition P_지역2 values ('경기', '인천'), 
    	...
    	partition P9999_MX values (DEFAULT)	
    );
    ```
    

### 인덱스 파티션

- 로컬 파티션 인덱스 : 별도 색인
- 글로벌 파티션 인덱스 : 파티션을 테이블과 다르게 구성
- 비파티션 인덱스 : 파티셔닝 X

### 파티션을 활용한 대량 INSERT 튜닝

- 비파티션 테이블일 때 : 손익분기점을 넘는 대량 데이터를 INSERT 하려면, 아래와 같이 인덱스를 Unusable 시켯다가 재생성하는 방식이 더 빠를 수 있음

- 순서
    - 테이블을 nologging 모드로 전환
    - 인덱스를 Unuable 상태로 전환
    - Direct Path Insert 방식으로 대량 데이터를 입력
    - nologging 모드로 인덱스 재생성
    - nologging 모드로 작업했다면 다시 logging모드로 전환

### DML 로우 Lock

- 두 개 이상의 트랜잭션이 같은 로우 변경 방지
- DML 과 select의 경합은 X

### DML 테이블 Lock(TM Lock)

- 오라클은 DML 로우 Lock을 설정하기에 앞서 테이블 Lock을 먼저 실행
	- RS : row share
  	- RX : row exclusive
  	- S : share
  	- SRX : share roe exclusive
  	- X : exclusive

|      | Null | RS  | RX  | S   | SRX | X   |
|------|------|-----|-----|-----|-----|-----|
| Null | ○    | ○   | ○   | ○   | ○   | ○   |
| RS   | ○    | ○   | ○   | ○   | ○   |     |
| RX   | ○    | ○   | ○   |     |     |     |
| S    | ○    | ○   |     | ○   |     |     |
| SRX  | ○    | ○   | ○   |     |     |     |
| X    | ○    |     |     |     |     |     |

### 트랜잭션 동시성 제어

- 비관적 동시성 제어 : 후행 T가 기다림, for update를 통해 Lock을 얻기 위해 무한정 기다리는 것을 방지
- 낙관적 동시성 제어 : 버저닝

</details>

<details>
  <summary>7. 옵티마이저 튜닝</summary>


  
</details>
