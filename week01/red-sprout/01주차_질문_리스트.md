# 1주차 질문 리스트

## 학습 범위
- 1장: SQL 처리 과정과 I/O
- 2장: 인덱스 기본
- 3장: 인덱스 튜닝
- 4장: 조인 튜닝

## 이해 안되는 부분
### 옵티마이저
- 예상되는 실행 계획과 실제 실행 계획이 다르게 나타남
```sql
create unique index emp_no_name on EMPLOYEE(EMP_ID, EMP_NAME);

select *
from EMPLOYEE
where EMP_ID = 208;
```
#### 예상되는 실행 계획
```
-------------------------------------------------------------------------------------------------
| Id  | Operation                   | Name        | Rows  | Bytes | Cost (%CPU)| Time     |
-------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT            |             |     1 |   111 |     2   (0)| 00:00:01 |
|   1 |  TABLE ACCESS BY INDEX ROWID| EMPLOYEE    |     1 |   111 |     2   (0)| 00:00:01 |
|*  2 |   INDEX UNIQUE SCAN         | EMP_NO_NAME |     1 |       |     1   (0)| 00:00:01 |
-------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------
   2 - access("EMP_ID"=208)
```

#### 실제 실행 계획
```
------------------------------------------------------------------------------
| Id  | Operation         | Name     | Rows  | Bytes | Cost (%CPU)| Time     |
------------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |          |     1 |   111 |     3   (0)| 00:00:01 |
|*  1 |  TABLE ACCESS FULL| EMPLOYEE |     1 |   111 |     3   (0)| 00:00:01 |
------------------------------------------------------------------------------
```
<details>
<summary>Claude의 답변</summary>

- 테이블 크기가 매우 작음
- 테이블 블록 수가 적을 때 (예: 1-2 블록)
- 인덱스 접근 비용 > 테이블 전체 스캔 비용
- 작은 테이블에서는 FULL SCAN이 더 효율적
</details>

### IOT(인덱스 구조 테이블), 클러스터 테이블
- Oracle은 IOT와 클러스터 테이블 개념이 존재
- MySQL은 비슷한 개념으로 클러스터링 인덱스와 넌클러스터링 인덱스 개념이 존재
- 둘의 비교?
<details>
<summary>Claude의 답변</summary>

## 정확한 대응 관계 분석

### **Oracle IOT ↔ MySQL 클러스터링 인덱스**
이 둘은 **거의 동일한 개념**입니다.

#### **공통점:**
- 데이터가 키 순서로 **물리적 정렬** 저장
- **인덱스 구조 = 테이블 구조**
- 리프 노드에 실제 데이터 저장
- 범위 검색 시 순차 블록 읽기

#### **차이점:**
```sql
-- Oracle: 명시적 생성
CREATE TABLE emp_iot (...) ORGANIZATION INDEX;

-- MySQL: 자동 생성 (PK 기준)
CREATE TABLE emp (..., PRIMARY KEY(id)) ENGINE=InnoDB;
```

---

### **Oracle 클러스터 테이블 ↔ MySQL에는 직접 대응 없음**

Oracle 클러스터는 **독특한 개념**으로 MySQL에는 정확히 대응되는 기능이 없습니다.

#### **Oracle 클러스터의 고유 특징:**
```sql
CREATE CLUSTER order_cluster (customer_id NUMBER);
CREATE TABLE orders (...) CLUSTER order_cluster (customer_id);
CREATE TABLE order_items (...) CLUSTER order_cluster (customer_id);
```
- **여러 테이블이 같은 물리적 블록 공유**
- 같은 customer_id를 가진 orders와 order_items가 인접 저장

#### **MySQL의 유사한 접근법들:**
1. **파티셔닝**
```sql
CREATE TABLE orders (...)
PARTITION BY HASH(customer_id) PARTITIONS 4;
```

2. **MyISAM의 MERGE 테이블** (deprecated)
```sql
CREATE TABLE all_orders (...) ENGINE=MERGE 
UNION=(orders_2023, orders_2024);
```

3. **실무 해결책: 애플리케이션 레벨**
```sql
-- 관련 데이터를 JSON으로 통합
CREATE TABLE customer_data (
    customer_id INT,
    orders JSON,
    order_items JSON
);
```

---

## **실제 대응 관계 정리**

| Oracle 개념 | MySQL 대응 | 유사도 |
|-------------|------------|--------|
| **IOT** | **클러스터링 인덱스** | ⭐⭐⭐⭐⭐ (거의 동일) |
| **클러스터 테이블** | **직접 대응 없음** | ❌ |
| **일반 테이블** | **넌클러스터링** | ⭐⭐⭐ |

## **왜 MySQL에 클러스터 테이블이 없을까?**

### **철학적 차이:**
- **Oracle**: 복잡한 기업용 기능 제공
- **MySQL**: 단순하고 빠른 성능 중심

### **기술적 이유:**
- MySQL InnoDB는 **페이지 기반 구조**
- 여러 테이블을 같은 페이지에 혼합 저장하기 복잡
- **조인 최적화**를 다른 방식으로 해결 (인덱스 최적화, 쿼리 최적화)

## **결론**

- **IOT ↔ 클러스터링 인덱스**: 완벽 대응 ✅
- **Oracle 클러스터**: MySQL에는 독특한 Oracle만의 기능 ❌
- 실무에서는 **파티셔닝**이나 **애플리케이션 레벨 최적화**로 유사 효과 달성

Oracle 클러스터의 조인 최적화 효과는 MySQL에서 **더 나은 인덱스 설계**와 **쿼리 최적화**로 대체하는 것이 일반적입니다.
</details>

## 새롭게 알게 된 부분
### 1. SQL 처리 과정과 I/O
> 테이블스페이스 → 세그먼트 → 익스텐트 → 블록 → 로우

- `테이블스페이스` : 세그먼트를 담는 컨테이너
- `세그먼트` : 테이블, 인덱스, 파티션, LOB(Large Object) 같이 저장 공간이 필요한 영역
- `익스텐트` : 공간을 확장하는 단위, 여러 블록들로 구성
- `블록` : 레코드를 실제로 저장하는 공간, 페이지라고도 불림
    - 한 블록은 하나의 테이블이 독점 → 한 블록에 저장된 레코드는 모두 같은 테이블 레코드
    - `DBA(Data Block Address)` : 디스크 상에서 몇 번째 블록인지 나타냄
    - 테이블 스캔 시 : 익스텐트 맵 활용 → 첫 번째 블록 DBA → 블록은 연속이므로 Scan 가능
- `데이터파일` : 디스크 상의 물리적인 OS 파일

> 익스텐트 내 블록은 서로 인접, 익스텐트 끼리는 불연속!

#### 버퍼캐시 히트율(Buffer Cache Hit Ratio, BCHR)

```
BCHR = (캐시에서 곧바로 찾은 블록 수 / 촌 읽은 블록 수) * 100
	= ((논리적 I/O - 물리적 I/O) / (논리적 I/O)) * 100
	= (1 - (물리적 I/O) / (논리적 I/O)) * 100
```

```
물리적 I/O = 논리적 I/O * (100% - BCHR)
```

- 논리적 I/O 줄이기 - **SQL을 튜닝해서 읽는 총 블록 개수 줄이기**

### 2. 인덱스 기본
#### Range Scan의 조건
1. 인덱스 컬럼을 가공하는 경우 불가능
2. LIKE로 중간값 검색시 불가능
3. OR, IN
- OR, IN 단순 사용시 수직적 탐색을 통한 시작 지점을 찾을 수 없음
- UNION ALL 이나 `/*+ use_concat */` 힌트를 통해 OR Expansion 유도 가능
4. 인덱스의 선두 컬럼이 가공하지 않은 상태로 조건절에 있어야 함
5. 자동 형변환시 칼럼이 가공될 수 있음, 가급적 형변환 필요시 `TO_CHAR` 등등 직접 적어줄 것

#### Index Range Scan
- 인덱스 루트에서 리프 블록까지 수직적으로 탐색 후 **필요한 범위**만 스캔
```sql
create index EMP_DEPTNO_IDX on EMP(DEPTNO);

select * from EMP where DEPTNO = 20;
```
```
------------------------------------------------------------------------------------------------------
| Id  | Operation                           | Name           | Rows  | Bytes | Cost (%CPU)| Time     |
------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                    |                |     5 |   105 |     2   (0)| 00:00:01 |
|   1 |  TABLE ACCESS BY INDEX ROWID BATCHED| EMP            |     5 |   105 |     2   (0)| 00:00:01 |
|*  2 |   INDEX RANGE SCAN                  | EMP_DEPTNO_IDX |     5 |       |     1   (0)| 00:00:01 |
------------------------------------------------------------------------------------------------------
```

#### Index Full Scan
- 수직적 탐색 없이 인덱스 리프 블록을 처음부터 끝까지 수평적으로 탐색
- 극히 일부 데이터 조회할 경우는 Table Full Scan 보다는 효과적
- 수행빈도가 낮으면 상관없지만, **조건절 컬럼 순서**를 지키는 인덱스를 설계할 것
```sql
create index emp_ename_sal_idx on EMPLOYEE(EMP_NAME, SALARY);

select *
from EMPLOYEE
where SALARY > 2000000
order by EMP_NAME;
```
- 인덱스 있는 경우(Index Full Scan) : `ORDER BY` 연산 생략
```
-------------------------------------------------------------------------------------------------
| Id  | Operation                   | Name              | Rows  | Bytes | Cost (%CPU)| Time     |
-------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT            |                   |    18 |  1998 |     2   (0)| 00:00:01 |
|   1 |  TABLE ACCESS BY INDEX ROWID| EMPLOYEE          |    18 |  1998 |     2   (0)| 00:00:01 |
|*  2 |   INDEX FULL SCAN           | EMP_ENAME_SAL_IDX |     1 |       |     1   (0)| 00:00:01 |
-------------------------------------------------------------------------------------------------
```
- 인덱스 없는 경우(Table Full Scan)
```
-------------------------------------------------------------------------------
| Id  | Operation          | Name     | Rows  | Bytes | Cost (%CPU)| Time     |
-------------------------------------------------------------------------------
|   0 | SELECT STATEMENT   |          |    18 |  1998 |     4  (25)| 00:00:01 |
|   1 |  SORT ORDER BY     |          |    18 |  1998 |     4  (25)| 00:00:01 |
|*  2 |   TABLE ACCESS FULL| EMPLOYEE |    18 |  1998 |     3   (0)| 00:00:01 |
-------------------------------------------------------------------------------
```

#### Index Unique Scan
- 오로지 **수직적 탐색**으로 스캔
- `=` 조건으로 탐색
- Unique 인덱스 존재시 컬럼은 중복 X - 데이터를 한 건 찾는 순간 중지
- 데이터가 너무 적으면 옵티마이저가 Unique Scan 대신 Table Full Scan을 선택하기도 함. 

#### Index Skip Scan
- 인덱스 선두 칼럼이 조건절에 없어도 인덱스를 활용
- 인덱스의 선두 컬럼의 Distinct Value 개수가 적고 후행 컬럼의 Distinct Value 개수가 많을 때 유용
- `index_ss` : 유도, `no_index_ss` : 방지
- 발동 조건
  - (선두) + 중간 + 끝 : Skip Scan 사용 가능
  - 선두 + (중간) + 끝 : Skip Scan 사용 가능
  - (선두 + 중간) + 끝 : Skip Scan 사용 가능
  - Index Skip Scan 사용시 포함 가능성 있는 리프 블록만 골라서 액세스 가능
- 기본적으로는 최적의 Index Range Scan을 목표 - 일부 상황에 대해 차선책으로 다른 스캔 방식들 검토

#### Index Fast Full Scan
- 인덱스의 논리적 구조 대신 디스크 저장 순서대로 스캔
- 인덱스 키 순서대로 정렬되지 않음

#### Index Range Scan Descending
- Index Range Scan 이지만, 거꾸로 스캔

### 3. 인덱스 튜닝
#### 인덱스 손익분기점
- Index Range Scan에 의한 테이블 액세스가 Table Full Scan보다 느려지는 지점
- 데이터가 모여있는 정도인 클러스터링 팩터(Clustering Factor, CF)가 좋을수록 손익 분기점이 올라감

| Index Range Scan | Table Full Scan |
| --- | --- |
| 추출 건수가 많을수록 느려짐 | 성능 일정 |
| 랜덤 액세스 | 시퀀셜 액세스 |
| Single Block I/O | Multiblock I/O |

#### 온라인 프로그램 튜닝 vs 배치 프로그램 튜닝

| 온라인 프로그램 | 배치 프로그램 |
| --- | --- |
| 소량의 데이터를 읽고 갱신 | 대량의 데이터를 읽고 갱신 |
| 인덱스 + NL 조인 활용 | 전체를 빠르게 - Full Scan과 Hash 조인 |
| - | 초대량 테이블의 경우 파티션, 병렬 처리 활용 고려 |

#### 인덱스에 컬럼 추가
- 기존 인덱스에 필요한 컬럼을 추가함으로써 성능 개선 가능
- 컬럼을 늘리는 건 좋지만 추가할 컬럼이 많아지면?

#### 인덱스 구조 테이블
- IOT(Index-Organized Table) : 랜덤 엑세스가 아예 발생하지 않도록 테이블을 인덱스 구조로 설정
- 흔히 다른 RDBMS에서 **클러스터형 인덱스**라 부르는 그거
- CF 향상을 목적
- `organization index;` : 테이블을 인덱스 구조로 생성
- `organization heap;` : 일반 테이블(보통 생략)

#### 클러스터 테이블
- 인덱스 클러스터 테이블
- 해시 클러스터 테이블

#### 부분 범위 처리
- DBMS는 일정량씩 데이터를 나누어 전송 - 추가 Fetch Call을 받기 전까지 정지
- 대량 데이터가 필요하다면 Array Size를 늘려 Fetch Call 감소
- 앞쪽 일부만 Fetch 한다면 지나치게 큰 Array Size는 낭비

#### 인덱스 스캔 효율화
- `인덱스 엑세스 조건`: 인덱스의 스캔 범위를 결정하는 조건절
- `인덱스 필터 조건`: 테이블로 액세스할지를 결정하는 조건
- `테이블 필터 조건`: 쿼리 수행 다음 단계로 전달하거나 최종 결과집합에 포함할지를 결정
- `옵티마이저의 비용`: 다음 항목들의 총합
  - 인덱스의 수직적 탐색 비용(인덱스 루트와 브랜치 레벨에서 읽는 블록 수)
  - 인덱스의 수평적 탐색 비용(인덱스 리프 블록을 스캔하는 과정에 읽는 블록 수)
  - 테이블 랜덤 액세스 비용(테이블 액세스 과정에 읽는 블록 수)
- 첫 번째 나타나는 범위 검색 조건까지만 만족하는 인덱스 레코드는 모두 연속해서 모여있지만, 그 이하 조건까지 만족하는 레코드는 비교 연산자 종류에 상관 없이 흩어짐
- `BETWEEN` - `IN-List`로 전환
  - 데이터 분포를 고려할 필요 있음
- Index Skip Scan 활용

#### 인덱스 설계
1. 조건절에 항상 사용하거나, 자주 사용하는 컬럼을 선정
2. '=' 조건으로 자주 조회하는 컬럼을 앞쪽에 둠

### 4. 조인 튜닝
#### NL 조인
- Nested Loop 조인, 다중 for 문을 생각하면 된다.
- 순차적으로 값을 찾아서 조인하기에 해당 칼럼에 인덱스 설정이 중요, 안그러면 Table Full Scan
- 소량의 데이터를 가진 테이블을 Outer Table, 반대는 Inner Table로 하는 것이 유리
#### sort merge 조인
- 뭔가 머지 소트가 생각나면 그 방식이 맞습니다.
  - 각 테이블을 인덱스를 활용해서 정렬 후 합치기
- NL 조인이 비효율적일 때 많이 사용
- Random Access 발생 X
- PGA 영역에서 진행되기에 빠름
#### hash 조인
- 조인되는 컬럼이 hash 영역에 올라감
- hash 영역 역시 PGA 영역이기에 빠름
- hash 용량 제한이 있어서 너무 큰 데이터는 다루기가 힘들다.