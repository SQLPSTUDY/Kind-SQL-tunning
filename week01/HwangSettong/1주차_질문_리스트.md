## 학습 범위
- 1장 SQL 처리 과정과 I/O
- 2장 인덱스 기본
- 3장 인덱스 튜닝
- 4장 조인 튜닝
<br/><br/><br/>
## 이해 안되는 부분
- 선택도 낮은 컬럼을 앞에 두면 좋은가?가 왜 아닌데

    선택도가 낮더라도 그 컬럼이 항상 쿼리의 시작 조건이 아닐 수 있음

    B*트리는 선두 컬럼부터 정렬되기 때문에, 앞에 있는 컬럼 조건이 빠지면 전체 인덱스를 못 씀

    따라서, 자주 쓰이는 조건 컬럼, 정렬이 필요한 컬럼, 조인 조건 컬럼 등을 고려해야 함
<br/>

- case절에서 자동 형 변환

    THEN ELSE 절에 따라 type을 유추하고 일반적인 type 따라감
<br/>

- 3개 이상 테이블의 해시 조인에서 Build / Probe 테이블 결정 기준
  
    테이블 작은 게 Build. 또는 조인 결과가 작은게 Build input.
    
<br/><br/><br/>
## 새롭게 알게 된 부분
### 1장 SQL 처리 과정과 I/O

- 소프트 파싱 vs 하드파싱
    
    ```sql
    SQL 파싱 → 라이브러리 캐시에 존재O → 실행 : 소프트 파싱
          ㄴ→ 라이브러리 캐시에 존재 X → 최적화 및 로우 소스 생성 → 실행 : 하드파싱
    ```
<br/>    

- 바인딩의 중요성
    
    ```sql
    select * from customer where login_id = 'user1'
    select * from customer where login_id = 'user2'
    select * from customer where login_id = 'user3'
    ...
    ```
    
    위 sql은 모두 각각의 프로시저로 처리되어 라이브러리 캐시에 적재되고, 많은 양이 적재되면 하드 파싱으로 인해 DB 성능에 문제가 생길 수 있음
    
    ```sql
    create procedure LOGIN(login_id in varchar2){ ... }
    ```
    
    위와 같이 login_id 를 파라미터 변수로 받는 프로시저를 하나로 공유하면서 재사용하기
    
<br/>    


- 라이브러리 캐시 vs DB 버퍼 캐시
    
    라이브러리 캐시는 DB 저장형 함수/프로시저 등을 캐싱하는 ‘코드 캐시’
    
    DB 버퍼캐시는 데이터 블록을 캐싱해두는 ‘데이터 캐시’
    
<br/>    

- 버퍼캐시 히트율(BCHR)
    
    버퍼캐시에 적재된 블록을 읽을 확률. BCHR이 높을 수록 성능 좋음.
    
    ```sql
    (1 - (물리적IO / 논리적IO)) * 100
    ```
    
    BCHR을 높이기 위해서는 논리적 IO를 줄여야 함.
    
    * 같은 블록을 비효율적으로 반복해서 읽어도 BCHR이 높아짐. BCHR이 높다고 효율적인 SQL인 것은 아님.
    
<br/>    

- Single Block I/O vs Multiblock I/O
    
    DB 버퍼캐시에 없으면 I/O Call을 통해 적재.
    
    Single Block I/O : I/O Call 시 한 블록씩 요청. 인덱스 이용 시 인덱스와 테이블 블록이 이를 사용.
    
    Multiblock I/O : I/O Call 시 여러 블록씩 요청. 테이블 전체를 스캔할 때 이를 사용.
    

<br/>    

- 버퍼 캐시 래치 vs 버퍼 캐시 락
    
    버퍼 캐시 래치 : 여러 세션이 버퍼 관리 구조체 에 접근할 때 충돌 방지
    
    버퍼 락 : 여러 세션이 같은 데이터 블록을 읽거나 변경할 때 충돌 방지
    
    | 항목 | 래치 (Latch) | 락 (Lock) |
    | --- | --- | --- |
    | 목적 | 메모리 구조 보호 | 데이터 무결성 보호 |
    | 대상 | 해시 체인, 캐시 구조 등 | 데이터 블록, 행(Row), 객체 |
    | 유지 시간 | 매우 짧음 (마이크로초 단위) | 트랜잭션이 끝날 때까지 유지 |
    | 종류 | Spin Lock 계열 | 대기 큐 기반 (Enqueue) |
    | 경합 시 | CPU 소비 증가, Latch wait 발생 | 트랜잭션 Blocking, Deadlock 가능 |
    
    버퍼 캐시를 도서관이라고 할 때, 버퍼 캐시 래치는 "책장 열쇠", 버퍼 블록 락은 "책 사용권”
    

<br/>    

### 2장 인덱스 기본

- 인덱스의 수직적 탐색 / 수평적 탐색
    
    수직적 탐색 : 인덱스 스캔 시작 지점을 찾는 과정
    
    수평적 탐색 : 데이터를 찾는 과정
    

<br/>    

- 결합 인덱스 생성 시 선택도가 낮은 컬럼을 앞에 둬야 한다?
    
    ```sql
    선택도가 낮은 컬럼을 앞쪽에 두고 결합 인덱스를 생성해야 검사 횟수를 줄일 수 있어 성능에 유리
    선택도 = (조건을 만족하는 행 수) / (전체 행 수)
    즉, 선택도가 낮다 = 거의 유일한 값 → 효율적인 필터링
    ```
    
    하지만, 실제 인덱스 구조인 B*트리는 찾고 나면 어디서든 **리프 노드부터 순차 접근**이므로, 컬럼 순서 자체는 일의 양에는 큰 차이를 안 줄 수 있음.
    
    조건절에서 자주 쓰는/선택도가 높은/ 조건 앞쪽에 자주 오는 컬럼 등을 기준으로 인덱스 설계
    

<br/>    

- Index Range Scan 이 불가능한 경우
    1. 조건절에 인덱스의 선두 컬럼이 포함되지 않은 경우
        
        ```sql
        -- 인덱스: (A, B)
        SELECT * FROM table WHERE B = 10 ORDER BY A;
        -- INDEX SKIP SCAN이나 INDEX FULL SCAN으로..
        ```
        
    2. 함수나 표현식이 적용된 경우
        
        ```sql
        -- 인덱스: (A, B)
        SELECT * FROM table WHERE SUBSTR(A, 1, 3) = 'abc';
        -- 함수 기반 인덱스로 보완 가능
        ```
        
    3. LIKE 조건이 와일드카드(%)로 시작하는 경우
        
        ```sql
        -- 인덱스: (name)
        SELECT * FROM table WHERE name LIKE '%철수';
        ```
        
    4. IN 조건이 여러개 걸려 있을 경우
        
        ```sql
        -- 인덱스: (A)
        SELECT * FROM table WHEREA IN (1, 2, 3, ..., 1000);
        ```
        
    5. OR 조건이 여러 컬럼에 걸려 있을 경우
        
        ```sql
        -- 인덱스: (A, B)
        SELECT * FROM table WHERE A = 10 OR B = 20;
        ```
        
    
    * IN이나 OR 조건절은 옵티마이저의 쿼리변환 기능을 통해 Index Range Scan으로 처리되기도 함. (UNION ALL 처리)
    

<br/>    

- 소트 생략 (skip sort)
    
    인덱스가 정렬된 순서를 유지하고 있다면 ORDER BY 절에서 별도의 소트 연산 없이 인덱스 순서대로 결과를 가져올 수 있음.
    
    INDEX RANGE SCAN + ORDER BY 조합에서 발생
    
    ㄴ단, ORDER BY의 컬럼 순서와 인덱스 정의 순서가 정확히 일치해야 하고, 가공하지 않은 상태여야 함.
    
    `MIN`과 `MAX` 함수에서 발생
    
    ㄴ함수에 들어가는 컬럼 값을 가공하지 않은 상태여야 함.
    
    ㄴ 예) `NVL(MAX(TO_NUMBER(변경순번)),0)` X /  `NVL(MAX(변경순번)),0)` O
    

<br/>    

- 자동형변환
    
    날짜형 + 문자형 → 날짜형
    
    숫자형 + 문자형 → 숫자형
    
    decode(a, b, c, b) → c의 type을 따라가고, 만약 c가 null이면 varchar2로 취급
    
    ❓case절에서는 ?? `THEN ELSE` 절에 따라 type을 유추하고 일반적인 type 따라감
    

<br/>    

- 인덱스 스캔 종류
    
    | 인덱스 스캔 방식 | 사용 조건 / 특징 | 주 용도 및 장단점 |
    | --- | --- | --- |
    | **Index Unique Scan** | - **유일 인덱스**
    - **= 조건**으로 **정확히 하나의 row** 찾을 때 | 가장 빠름.
    단 하나의 row만 필요할 때만 사용 가능 |
    | **Index Range Scan** | - **선두 컬럼 포함**한 조건
    - 범위 조건 (`BETWEEN`, `<`, `LIKE`) 등 | 흔히 사용됨.
    결과가 여러 건일 수 있음 |
    | **Index Skip Scan** | - **선두 컬럼 조건 없음**, **후행 컬럼 조건 존재** 
    - 선두 컬럼 값이 적을수록 효율 | 가능하지만 성능 이슈 발생 가능 |
    | **Index Full Scan** | - **선두 컬럼 없어도 가능** 
    - `ORDER BY` 등 정렬 목적 
    - 인덱스가 커도 가능 | 순차 접근이지만 rowid 접근 필요
    → 테이블 I/O 발생 |
    | **Index Fast Full Scan** | - **정렬 필요 없음** 
    - `ORDER BY` 없음 
    - **인덱스만으로** 원하는 컬럼 조회 시 | 정렬 없이 병렬 가능.
    테이블 액세스 없이 끝내는 경우에 적합 |

<br/>    

### 3장 인덱스 튜닝

<br/>    

- CF(clustering factor)
    
    CF가 좋은 컬럼은?
    
    → 인덱스 순서와 테이블 레코드 저장 순서가 비슷함
    → 인덱스 스캔 후 테이블 접근 시, 같은 블록에서 여러 레코드를 가져올 수 있음
    → 결과적으로 블록 I/O가 적게 발생함
    

<br/>    

- 온라인프로그램 튜닝 vs 배치프로그램튜닝
    
    온라인프로그램튜닝→ 주로 소량 데이터→ 인덱스 활용, NL조인 이용
    
    배치프로그램튜닝→ 주로 대량 데이터→ 전체범위 처리 기준 고려 Full Scan, 해시 조인 이용
    
    ❗️초대용량 테이블에서는 파티션 활용, 병렬처리 고려
    
<br/>    

- 인덱스로 인해 필터링해도 버려지는 레코드가 거의 없다면?
    
    쿼리에서 사용되는 컬럼을 모두 인덱스에 추가하는 방법을 통해 테이블 엑세스가 아예 발생하지 않게 하기
    
    ㄴ 조회 성능은 좋아진다만, DML 성능이 안좋아질 수 있고 인덱스 유지비용 증가
    

<br/>    

- include 인덱스
    
    (오라클엔 없음) 인덱스 키 외에 리프 레벨에 지정한 컬럼을 함께 저장하는 기능
    
    `create index emp_x01 on emp (deptno) include (sal)` 
    
    수직적 탐색에는 deptno만 사용하고 수평적 탐색에는 sal 도 함께 필터 조건으로 사
    

<br/>    

- IOT(Index Organized Table)
    
    인덱스 구조의 테이블. 즉, 인덱스 리프 블록이 곧 데이터 블록.
    
    일반 테이블(힙 구조 테이블)에서는 데이터 입력 시 정렬 없음.
    
    인덱스 구조 테이블은 정렬 상태를 유지하며 데이터를 입력. → CF가 좋아짐.
    

<br/>    

- 클러스터 테이블
    
    인덱스 클러스터 테이블 : 클러스터 키 값이 같은 레코드를 한 블록에 모아서 저장하는 방식
    해시 클러스터 테이블 : 인덱스를 사용하지 않고 특정 키를 가지고 해시 알고리즘을 사용해 클러스터를 찾음
    

<br/>    

- 부분범위처리 160

<br/>    

- 옵티마이저 Access/Filter 방법
    - 인덱스 엑세스 : 인덱스를 탐색해서 어떤 rowid를 찾아낼 때 사용. 빠름
    - 인덱스 필터 : 인덱스를 사용하지만, 전 범위를 스캔하면서 조건을 걸러냄.
    - 테이블 필터 : 인덱스를 통해 rowid를 찾고 테이블에서 데이터를 읽을 때 추가 조건을 필터링 하는 것.

<br/>    

- 인덱스 선행 컬럼이 `=` 이 아니면?
    - **`=` 조건은 인덱스 엑세스로 가장 효율적인 조건 중 하나**
    - Between, Like 같은 범위검색 조건이면 비효율이 생김
        
        Between → 사이 값이 적고, depth 가 낮으면 In-list 방식/ 아니면 NL조인 사용
        
    - IN 조건은 IN List Iterator 방식으로 `=` 처럼 사용될 수 있음
        
        하지만, 선택도가 높거나(즉, 너무 많은 값을 반환하거나) IN 리스트가 너무 크면 오히려 비효율적.
        

<br/>    

- OR조건
    - 선두컬럼에 or 조건을 걸면 인덱스 안탐.
        
        ㄴ b-tree는 선두 컬럼 기준으로 정렬되는데 or은 서로 다른 조건을 묶는 것이라서 이로인해 정렬된 경로가 깨질 수 있음
        
        ㄴ근데, `A=1 or A=2` 같은 건 `IN(1, 2)` 로 옵티마이저가 인식해서 index range scan 가능
        
        ㄴ 인덱스 구성 컬럼 중 하나 이상이 not null  컬럼이면, 18c 부터는 인덱스 필터조건으로 사용 가능
        
<br/>    

- Like/Between 사용 위치
    
    인덱스 선두 컬럼 ← 전체 데이터를 스캔해서 필터링 할 수 도 있음
    
    NULL 허용 컬럼 ← between 범위 안에 null 포함되지 않고, index에 null 데이터는 저장 안함. 결과에 누락 발생할 수 있음
    
    숫자형 컬럼 ← like 검색 시 문자열로 자동 형변환 해버릴 수 있음.
    
    가변 길이 컬럼 
    

<br/>    

### 4장 조인 튜닝

- NL(Nested loop) 조인
    - 말 그대로 중첩 루프문을 사용하여 조인
        
        일반적으로 outer inner 양쪽 테이블 모두 인덱스를 사용하는데 특히나 inner 쪽 테이블은 방문 빈도가 더 크므로 인덱스 필수
        
    - 튜닝 시 고려할 것
    - 랜덤엑세스 위주의 조인 방식이다
    - 조인을 한 레코드씩 순차적으로 진행한다.
    - nl조인은 결국 인덱스 조인이므로 인덱스 튜닝 방식 참고.
        1. 조인 순서를 변경해서 랜덤 액세스를 줄일 수 있는가?
        2. 더 추가하거나 효과적인 다른 인덱스가 있는가?
    - 주로 소량 데이터를 처리하거나 부분 범위 처리가 가능한 OLTP 시스템에 적합하다
    - 테이블 Prefetch , 배치 I/O
        - 테이블 prefetch : 인덱스를 이용해 테이블을 액세스 하다가디스크 IO가 필요해지면 이어서 곧 읽게될 블록까지 미리 읽어서 버퍼캐시에 적재하는 기능
        - 배치 IO : 디스크 IO call을 미뤄뒀다가 읽을 블록이 일정량 쌓이면 한꺼번에 처리하는 기능
        
        이를 표현한 실행계획 책 270p 참고
        
    

<br/>    

- SGA / PGA
    
    
    | 항목 | **SGA (System Global Area)** | **PGA (Process Global Area)** |
    | --- | --- | --- |
    | **역할** | 여러 프로세스가 공유하는 메모리 공간 | 각 프로세스가 단독으로 사용하는 메모리 공간 |
    | **용도** | 캐시된 데이터, SQL 실행 계획 등 공용 정보 저장 | 정렬/해시 조인 등 세션 고유 작업 처리 |
    | **공유 여부** | 공유함 | 공유하지 않음 |
    | **락 필요 여부** | Latch 등 락 필요 (동시 접근 조절) | 락 필요 없음 (독립적 사용) |
    | **속도** | 비교적 느림 (락으로 인한 경합 가능성 있음) | 빠름 (락 없이 독립 실행) |

<br/>    

- 소트 머지 조인
    - 양쪽 테이블로부터 조인 대상 집합을 **일괄적으로** 읽어서 PGA 공간에 저장한 후 NL 조인함.
        
        특히, 데이터 읽을 때 독립적인 메모리 공간 사용해서 래치 획득 과정이 없음.
        
        즉,  대량 데이터 조인에 유리함.
        
    - 소트 머지 조인은 양쪽 테이블을 정렬하는 부담이 있음
    - 대용량 데이터면서, 조인 조건식이 등치(=) 조건이 아닐 때 주로 사용
        
        등치조건일 땐 더 빠른 해시조건 사용하자
        
    - 조인 조건식이 아예 없는 cross join
    - 스캔 위주의 엑세스 방식 (조인 대상 레코드를 찾을 땐 랜덤 엑세스가 일어날 수 있음)

<br/>    

- 해시 조인
    - 작은 쪽 테이블(Build Input)을 읽어 PGA에 해시 테이블을 생성하고, 큰 쪽 테이블(Probe Input)을 읽어 해시 테이블을 탐색하면서 조인함.
        
        해시 테이블을 PGA 공간에 할당하므로 해시 테이블을 읽기 위한 래치 획득 과정이 없음
        
        소트 머지 조인은 “양쪽”을 모두 다 정렬하지만 해시조인은 “한쪽”만 읽어서 해시 맵 만듦.
        
        즉, 대량 데이터 조인에서 소트 머지 조인보다 더 유리함.
        
    - 해시 키 매칭을 위해 등치 조건(=)이 있는 조인에서만 사용 가능함.
    - 대용량일 때는 분할정복으로 나뉘어서 해시 조인을 처리
    - 해시테이블은 조인이 끝나면 바로 소멸하는 구조이므로, cpu와 메모리 사용률이 크게 증가하는 단점이 있음
    - 수행빈도가 낮고, 쿼리 수행시간이 오래 걸리는 대량 데이터를 조인할 때

<br/>    

- 서브 쿼리
    - 옵티마이저는 서브쿼리도 하나의 별개 쿼리로 보고 최적화를 수행함.
- 필터 오퍼레이션
    
    서브쿼리를 필터방식으로 처리. NL조인과 처리 루틴 같음
    
    - NL조인과 차이
        1. 서브쿼리가 조인에 성공하는 순간 진행 멈춤.
        2. 캐싱 기능을 갖고 있음. 동일한 조건을 캐시에서 찾음
        3. 조인 순서가 항상 고정. 메인 쿼리가 기준 테이블(outer)
- 서브쿼리 unnesting(서브쿼리 flattening)
    
    메인과 서브 쿼리 간 계층 구조를 풀어 서로 같은 레벨로 만들어 줌.
    
    필터 방식과 달리 조인 순서를 선택할 수 있게 됨.
    
    즉, 더 좋은 실행 경로를 찾을 가능성이 높아짐
    
    * 서브쿼리에 rownum 사용하면 unnesting 불가
    
- 서브쿼리 pushing
    
    unnesting 되지 않은 서브쿼리는 항상 필터 방식으로 처리되고, 주로 맨 마지막 단계에 처리됨.
    
    이들을 가능한 한 앞 단계에서 처리하도록 강제하는 기능.
    
- 인라인뷰와 조인
    
    인라인 뷰의 쿼리도 옵티마이저가 별개로 최적화 함 ← merge 힌트를 이용할 수 있음.
    
- 스칼라 서브쿼리
    
    select 문에 사용하면 메인쿼리 건수만큼 반복 실행 됨.
    
    이를 최소화 하기 위해 입출력 값을 내부 캐시(쿼리 실행 캐시)에 저장하여 이를 찾음.
    
    이것 때문에 캐시 공간 부족으로 인한 문제 발생할 수 있으니 확인 필요.
    
    스칼라 서브쿼리는 NL조인 방식으로 실행
