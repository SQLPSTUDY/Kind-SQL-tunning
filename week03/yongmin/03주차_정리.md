# Week3

고정하기: No
프로젝트: SQLP (https://www.notion.so/SQLP-24e0294679ba80e182c5e96cb6820ad5?pvs=21)

### SQL 최적화

1. SQL 파싱
    - 파싱 트리 생성 : SQL 문을 이루는 개별 구성요소를 분석해서 파싱 트리 생성
        - SQL 문장을 토큰 단위로 분리하는 것
            
            ```sql
            SELECT name FROM employee WHERE age > 30;
            
            => SELECT, name, FROM, employee, WHERE, age, >, 30;
            ```
            
    - Syntax 체크
    - Semantic 체크 : 의미상 오류 확인
2. SQL 최적화
    - 옵티마이저가 맡는 역할로, 미리 수집한 통계정보를 바탕으로 실행경로를 선택
3. 로우 소스 생성
    - 로우 소스 생성기가 맡는 역할로, 옵티마이저가 선택한 실행경로를 실제 실행 가능한 코드 또는 프로시저 형태로 포맷팅

### 옵티마이저

데이터 딕셔너리에 미리 수집해 둔 오브젝트 통계로 예상비용을 산정하여 최저 비용의 실행 계획을 선택하는 핵심 엔진

⇒ 단 룰 기반 일때는 통계 데이터에 따르지 않는다(이제는 사용 X)

### 옵티마이저 힌트

```sql
SELECT /*+ INDEX(A 고객_PK) */
			고객명, 연락처, 주소, 가입일시
	FROM 고객 A
 WHERE 고개ID = '0000008'
```

- 힌트 안에 인자를 나열할 때는 콤마(,) 사용이 가능하지만, 힌트 사이에는 안된다.
    - 콤마 기준 선행 힌트만 유효하다.

```sql
/*+ INDEX(A A_X01) INDEX(B B_X03) */ -> 모두 유효
/*+ INDEX(C), FULL(D) */             -> 첫 번쨰 힌트만 유효
```

- 테이블을 지정할 때는 스키마명까지 명시하면 안된다.

```sql
SELECT /*+ FULL(SCOTT.EMP) */ -> 무효
	FROM EMP
```

- FROM 절에 ALIAS를 사용했다면 반드시 명시해야한다.

```sql
SELECT /*+ FULL(EMP) */ -> X
  FROM EMP E

SELECT /*+ FULL(E) */ -> O
  FROM EMP E
```

### 소프트 파싱 VS 하드 파싱

System Global Area(SGA)의 라이브러리 캐시

- 로우 소스 생성 과정을 통해 생성한 프로시저

**소프트** → 이 라이브러리 캐시에서 최적화를 거치지 않고 찾아서 실행하는 것

**하드** → 최적화 단계부터 로우 소수 생성을 통해 프로시저를 생성해서 실행하는 것



### 이름이 없는 SQL 문제

라이브러리 캐시에 모두 적재하면 하드 파싱을 할 필요가 없잖아?

- SQL은 사용자 정의 함수/프로시저, 트리거, 패키지 등과 다르게 이름이 없다.
    - 즉, SQL 자체가 이름인 것
- SQL ID를 이름으로 사용해도(오라클 10g) SQL이 변하면 그 값을 유지할 수 없다.
    - SQL 전체 텍스트와 1:1 대응 관계
- 개발 과정에서 일회성, 필요없어지는 SQL이 많기 때문에 오히려 찾는 속도가 감소할 것이다.

```sql
SELECT * FROM emp WHERE empno = 7900;
select * from EMP where EMPNO = 7900;
...
```

⇒ 모두 같은 동작을 하지만, 라이브러리 캐시에는 별도의 공간을 차지한다.

그럼 어떻게 라이브러리 캐시를 최대한 활용할 수 있을까??

**Before**

```java
String SQLStmt = 
		"SELECT * FROM CUSTOMER WHERE LOGIN_ID = '"+ login_id + "'";
```

```sql
SELECT * FROM CUSTOMER WHERE LOGIN_ID = 'yongmin'
SELECT * FROM CUSTOMER WHERE LOGIN_ID = 'jaewan'
SELECT * FROM CUSTOMER WHERE LOGIN_ID = 'sehyeon'
```

⇒ 유저가 로그인할 때마다 라이브러리 캐시에 적재된다.

**After**

```java
String SQLStmt = 
		"SELECT * FROM CUSTOMER WHERE LOGIN_ID = ?";
```

```sql
SELECT * FROM CUSTOMER WHERE LOGIN_ID = :1
```

⇒ SQL을 작성할 때 바인드 변수를 직접 SQL넣지 않고 **파라미터 Driven** 방식으로 해결

### Oracle DB 저장 구조

![image.png](Week3%2024e0294679ba80b6b74cded7ae667cd9/image.png)

**Data Block** 

- 실질적인 데이터 저장
- Data File의 Os Block의 크기 단위로 I/O가 되어야 하기 때문에 OS Block의 배수 만큼의 크기를 가진다. (권장)
    - **OS Block 단위로 데이터 I/O가 발생한다.(8KB)**

**Extent**

- Data Block들(기본 5개)의 연속적인 집합
- Extent의 공간이 꽉 찰 경우 → 추가적인 Extent 할당
- 여러개의 Extent가 Data File에 속한다.
    - Data File의 Extent는 서로 다른 세그먼트 일 수 있다.
        
        ⇒ 물리적인 Data File의 위치에서는 논리적인 저장 구조와 다를 수도 있다라는 것을 보여줌
        

**Segment**

- 한개 이상의 Extent
- 하나의 Table, Index는 하나의 Segment에 저장한다.
- 한개 이상의 Extent를 가지고 있다. == 한개 이상의 Data File을 가진다.
    - 해당 Data File은 동일한 Tablespace에 속해야 한다.

**Tablespace**

- 하나 이상의 Segment
- 즉, 테이블/인덱스는 각 테이블스페이스에 속한다.

Q. LOB 컬럼?

- Large Object 타입 데이터를 저장하는 컬럼으로 대용량 바이너리나 텍스트를 저장하기 위해 설계된 데이터 타입
- 하나의 세그먼트 → 테이블, 인덱스와 동일

### Sequential Access

- 논리적 or 물리적으로 연결된 순서에 따라 순차적으로 Block을 읽는 방식
- Block간의 서로 연결되어있지 않은데 어떻게???
    - Segment Header에 Extent 정보를 가지는 Map에서 해당 Extent의 첫 Block부터 연속해서 읽는 것
    - Table Full Scan

### Random Access

- 원하는 레코드만 직접 엑세스하는 것
    - 데이터를 빨리 검색할 수 있다.

### DB 버퍼 캐시

코드 캐시 → SQL, 실행계획, DB 저장형 함수/프로시저

**DB 버퍼 캐시 → 데이터 캐시**

- 디스크에서 어렵게 읽은 데이터를 캐싱하여 I/O Call을 줄일 수 있다.
    - 결과적으로, 프로세스가 잠드는 시간이 줄어듬

### 논리적 I/O vs. 물리적 I/O

논리적: 메모리 I/O - DB 버퍼 캐시 경유

- 실제로 , 논리적 = 메모리 + Direct Path
- 전기적 신호

물리적: 디스크 I/O

- DB 버퍼 캐시에서 찾지 못할때만 디스크 I/O가 발생하니, 논리적 블록 I/O 중 일부를 물리적으로 I/O한다.
- Access Arm - 디스크 드라이버 내부에서 데이터를 읽거나 쓰기 위해 움직이는 기계 장치

### **BCHR(Buffer Cache Hit Ratio)**

```
BCHR = (캐시에서 곧바로 찾은 블록 수 / 총 읽은 블록 수 ) * 100
	   = ((논리적 I/O - 물리적 I/O) / 논리적 I/O) * 100
	   = ( 1 - (물리적 I/O) / (논리적 I/O) )  * 100

물리적 I/O = 논리적 I/O * (100% - BCHR)
```

물리적 I/O는 외생변수, BCHR은 시스템 상황에 따라 달라진다 .

**논리적 I/O를 줄임으로써 물리적 I/O를 줄이는 것이 곧 SQL 튜닝**

**Q. BCHR는 SQL 성능을 좌우 하지만, BCHR이 높다고 효율적인 SQL을 의미하진 않는다??**

- 같은 블록을 비효율적으로 반복해서 읽으면 BCHR이 높아진다.

```sql
SELECT e.empno, e.ename, d.dname
  FROM emp e
  JOIN dept d ON e.deptno = d.deptno;
```

- `emp`가 100만건, dept가 10만건
- 옵티마이저가 `dept` 인덱스를  매번 스캔하면, `dept` 블록은 한번 읽어서 캐시에 있지만, 100만 번의 논리적 I/O가 발생한다. → BCHR는 높지만, CPU는 혹사

### Single Block I/O vs. Multi Block I/O

**Single Block I/O** 

- **인덱스 루트 블록**
- 인덱스 루트 블록에서 얻은 주소 정보로 **브랜치 블록**
- 브랜치 블록에서 얻은 주소 정보로 **리프 블록**
- 리프 블록에서 얻은 주소 정보로 **테이블 블록**

**Multi Block I/O**

- 테이블 전체 스캔할 때 유용
- 일반적으로 1MB 단위로 I/O 수행
- Extent 경계를 넘을 수는 없다.

### Table Full Scan vs. Index Range Scan

**Table Full Scan**

- Sequential Access + Multi Block I/O
    - 소량 데이터 검색에 불리

**Index Range Scan**

- Random Access + Single Block I/O
    - 프로세스가 자주 잠듬
    - 한 블록에 평균 500개의 레코드가 있으면, 같은 블록을 최대 500번 읽는다.
        - 각 블록을 단 한번 읽는 Full Scan보다 불리
    
    ⇒ 한 블록에 500개의 레코드가 몰려 있고, 인덱스 접근이 그 블록을 **랜덤하게 여러 번 호출**해서 생기는 현상
    
    ⇒ 블록 안에 여러개의 레코드가 있고 index range scan은 single block I/O로 블록을 반복 호출하는 것
    

### 캐시 탐색 메커니즘

![image.png](Week3%2024e0294679ba80b6b74cded7ae667cd9/image%201.png)

- Direct Path I/O를 제외하고 모두 캐시를 경유한다.

**동작과정 (실제로는 더 복잡하다.)**

Hash 함수f(x) 에서 mod(x,5) 연산을 통해 나머지에 따라 Bucket이 정해지고 chain을 통해 연결한다. 

즉, chain내 순서는 보장되지 않는다. (나머지가 2인 Bucket인 경우, 27이 7보다 먼저 I/O가 발생할 수 있기 때문에)

SGA 내부에 있는 버퍼 캐시는 공유자원이기 때문에 **직렬화**가 필수

- 직렬화 == 줄세우기
- 여러 프로세스가 동시에 접근할 수 없도록 순서대로 해시 체인을 탐색한다.
    - Latch를 통해 접근한 프로세스만 체인에 관여할 수 있도록 하여, 탐색 과정 중 변경을 방지한다.
        
        ⇒ LRU 채인 래치
        
    - 또한, 버퍼 Lock을 통해, 데이터 정합성을 방지한다.
        - 선행 프로세스가 작업을 완료하고 Latch를 풀기 전, 버퍼 캐시에 I/O 동안 접근하지 못하도록 Lock을 수행한다.