### 1장 SQL 처리 과정과 I/O

- 테이블 통계 정보를 수집하는 명령어
    
    ```sql
    EXEC DBMS_STATS.GATHER_TABLE_STATS(스키마이름, '테이블명');
    ```
    
    통계가 없으면 비효율적인 실행계획을 생성할 수 있으므로 성능 테스트나 튜닝 전에는 통계 수집은 필수

<br/><br/>

- 힌트 정의 시 주의사항
    1. SELET 문 뒤에 와야함.
    2. 스키마명까지 명시하면 안됨.
    3. 테이블 별칭 지정 시 힌트에도 무조건 별칭 사용해야함.
    4. 힌트 안에 인자 나열 시 ’`,`’사용 가능. 힌트 사이에는 ’`,`’ 사용 불가능

<br/><br/>

- 소프트 파싱 vs 하드파싱
    
    ```sql
    SQL 파싱 → 라이브러리 캐시에 존재O → 실행 : 소프트 파싱
          ㄴ→ 라이브러리 캐시에 존재 X → 최적화 및 로우 소스 생성 → 실행 : 하드파싱
    ```

<br/><br/>
    

- 바인딩의 중요성
    
    ```sql
    select * from customer where login_id = 'user1'
    select * from customer where login_id = 'user2'
    select * from customer where login_id = 'user3'
    ...
    ```
    
    위 sql은 모두 각각의 프로시저로 처리되어 라이브러리 캐시에 적재되고, 많은 양이 적재되면 하드 파싱으로 인해 DB 성능에 문제가 생길 수 있음
    
    ```sql
    create procedure LOGIN(login_id in varchar2){ ... }
    ```
    
    위와 같이 login_id 를 파라미터 변수로 받는 프로시저를 하나로 공유하면서 재사용하기.
    
    해당 SQL에 대한 하드파싱은 최초 한번만 일어나고, 캐싱된 SQL을 사용.
 
<br/><br/>
   
- I/O와 프로세스
    
    디스크에서 데이터를 읽어야 할 때, 프로세스는 I/O Call 후 CPU를 OS에 반환.
    
    I/O 완료까지 대기 큐에서 대기.
    

<br/><br/>

- DB 저장구조
    
    <img width="654" height="499" alt="image" src="https://github.com/user-attachments/assets/7b4f120a-a4d5-45b2-adc5-a76b2d62f495" />
    
    - 테이블 스페이스 : 데이터베이스의 모든 데이터를 저장하는 논리적 컨테이너. 여러 개의 데이터 파일(Datafile)로 구성
    - 세그먼트: 데이터베이스 객체를 저장하는 공간. 테이블, 인덱스, 파티션 등 각 객체마다 고유한 세그먼트를 가짐
    - 익스텐드 : 세그먼트에 데이터가 늘어나면 새 익스텐트가 추가됨. 할당 단위이므로, 공간을 더 확보하려면 익스텐트를 새로 할당
    - 블록 : 디스크에서 읽고 쓰는 최소 단위

<br/><br/>

- 단편화
    
    <img width="671" height="391" alt="image" src="https://github.com/user-attachments/assets/cb226777-4f6a-440b-99ff-3b6cbf84b9a2" />

    - 외부단편화
        
        익스텐트끼리는 물리적으로 연속 될 필요가 없고, 객체들이 생성/삭제를 반복하면서 연속 공간 확보가 어려워져 익스텐트들이 물리적으로 떨어져 있는 경우가 많음.
        → 디스크 탐색이 증가
        
    - 내부단편화
        
        익스텐드는 연속된 블록 묶음이므로 할당 크기가 큼. 객체가 익스텐트를 다 채우지 못하면 발생
        
        → 다른 객체가 사용 불가능함. 낭비
        
 
<br/><br/>
   

- 라이브러리 캐시 vs DB 버퍼 캐시
    
    라이브러리 캐시는 DB 저장형 함수/프로시저 등을 캐싱하는 ‘코드 캐시’
    
    DB 버퍼캐시는 데이터 블록을 캐싱해두는 ‘데이터 캐시’
 
<br/><br/>
   
- 버퍼캐시 히트율(BCHR)
    
    버퍼캐시에 적재된 블록을 읽을 확률. BCHR이 높을 수록 성능 좋음.
    
    ```sql
    (1 - (물리적IO / 논리적IO)) * 100
    ```
    
    BCHR을 높이기 위해서는 논리적 IO를 줄여야 함.
    
    * 같은 블록을 비효율적으로 반복해서 읽어도 BCHR이 높아짐. BCHR이 높다고 효율적인 SQL인 것은 아님.
 
<br/><br/>
   
- Single Block I/O vs Multiblock I/O
    
    DB 버퍼캐시에 없으면 I/O Call을 통해 적재.
    
    Single Block I/O : I/O Call 시 한 블록씩 요청. 인덱스 이용 시 인덱스와 테이블 블록이 이를 사용.
    
    Multiblock I/O : I/O Call 시 여러 블록씩 요청. 테이블 전체를 스캔할 때 이를 사용.
    

<br/><br/>

- 버퍼 캐시 래치 vs 버퍼 캐시 락
    
    버퍼 캐시 래치 : 여러 세션이 버퍼 관리 구조체 에 접근할 때 충돌 방지
    
    버퍼 락 : 여러 세션이 같은 데이터 블록을 읽거나 변경할 때 충돌 방지


    | 항목 | 래치 (Latch) | 락 (Lock) |
    | --- | --- | --- |
    | 목적 | 메모리 구조 보호 | 데이터 무결성 보호 |
    | 대상 | 해시 체인, 캐시 구조 등 | 데이터 블록, 행(Row), 객체 |
    | 유지 시간 | 매우 짧음 (마이크로초 단위) | 트랜잭션이 끝날 때까지 유지 |
    | 종류 | Spin Lock 계열 | 대기 큐 기반 (Enqueue) |
    | 경합 시 | CPU 소비 증가, Latch wait 발생 | 트랜잭션 Blocking, Deadlock 가능 |
