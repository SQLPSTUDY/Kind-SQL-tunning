# 2장. 인덱스 기본

## 실습 데이터 만들기

```sql
CREATE TABLE EMP AS
SELECT E.EMP_NO,
       E.FIRST_NAME,
       E.LAST_NAME,
       E.BIRTH_DATE,
       MIN(D.DEPT_NO) AS DEPT_NO,
       MIN(DP.DEPT_NAME) AS DEPT_NAME,
       S.SALARY
FROM EMPLOYEES E
LEFT JOIN DEPT_EMP D  ON E.EMP_NO = D.EMP_NO
LEFT JOIN DEPARTMENTS DP ON D.DEPT_NO = DP.DEPT_NO
LEFT JOIN SALARIES S ON E.EMP_NO = S.EMP_NO
GROUP BY E.EMP_NO, E.FIRST_NAME, E.LAST_NAME, E.BIRTH_DATE, S.SALARY;

SELECT * FROM EMP;
```

## 인덱스 기본 사용법

### Index Range Scan

Index Range Scan은 인덱스의 가장 일반적이고 정상적인 액세스 방식입니다. 루트에서 리프까지 수직적 탐색이 선행되고, **필요한 범위**만 스캔하기에 읽기 성능을 개선하는 데 큰 도움이 됩니다. 이런 인덱스 range scan 시 주의사항을 알아보겠습니다.

> 인덱스 컬럼을 가공하면 인덱스를 정상적으로 사용(Range Scan)할 수 없다.

예를 들어서 생년월일을 기준으로 인덱스가 설정되어 있고 

```sql
CREATE INDEX BIRTH_IDX ON EMP(BIRTH_DATE);
```

이를 조회한다고 가정하보면,

```sql
SELECT BIRTH_DATE
FROM EMP
WHERE BIRTH_DATE BETWEEN DATE '1952-12-01' AND DATE '1953-01-01';
```

해당 데이터에 대해서는 인덱스가 시작점과 끝점을 찾아 해당 구간 사이에 있는 모든 데이터를 단순히 들고오면 됩니다.
하지만, 12월을 조회하면,

```sql
SELECT BIRTH_DATE
FROM EMP
WHERE EXTRACT(MONTH FROM BIRTH_DATE) = 12;
```

이므로 이는 1900년 일수도, 2000년 일수도, 극단적으로는 9999년 일수도 있기 때문에 인덱스가 따로 시작점과 끝점을 잡을 수가 없습니다. 즉 Range Scan이 불가능합니다.

비슷한 원리도 다음과 같은 경우는 인덱스 Range Scan이 되지 않습니다.

```sql
/* 1. NULL 처리 : 칼럼 가공이 들어가서 인덱스가 시작점을 찾지 못함 */
-- Table Full Scan
SELECT SALARY
FROM EMP
WHERE NVL(SALARY, 0) < 50000;

-- Index Range Scan
SELECT SALARY
FROM EMP
WHERE SALARY < 50000;

/* 2. LIKE 중간 검색 : 중간 검색은 시작점을 찾지 못함 */
-- Table Full Scan
SELECT FIRST_NAME
FROM EMP
WHERE FIRST_NAME LIKE '%Ir%';

-- Index Range Scan
SELECT FIRST_NAME
FROM EMP
WHERE FIRST_NAME LIKE 'Ir%';

-- 3. OR / IN 검색 조건
WHERE (EMP_NO = :EMP_NO OR FIRST_NAME = :FIRST_NAME)
WHERE DEPT_NO IN (:DEPT_NO1, :DEPT_NO2)

-- 쿼리 개선: RANGE SCAN 두 번으로 해결(UNION ALL 사용)
SELECT *
FROM EMP
WHERE FIRST_NAME = :FIRST_NAME
UNION ALL
SELECT *
FROM EMP
WHERE EMP_NO = :EMP_NO
AND (FIRST_NAME <> :FIRST_NAME OR FIRST_NAME IS NULL)
```

> 인덱스로 Range Scan 하기 위한 가장 첫 번째 조건은 인덱스 선두 컬럼이 가공되지 않은 상태로 조건절에 있어야 한다.

인덱스 선두 컬럼이 먼저 조건절에 없으면 인덱스가 시작점을 찾는 것이 불가능합니다. 반대로 인덱스 선두 컬럼이 가공되지 않았고 첫번째 조건으로 등장한다면, 그 다음 칼럼을 가공하더라도 Index Range Scan이 가능합니다.

```sql
CREATE INDEX BIRTH_FIRST_IDX ON EMP(BIRTH_DATE, FIRST_NAME);

SELECT *
FROM EMP
WHERE BIRTH_DATE = '1959-03-31'
  AND FIRST_NAME LIKE '%Ir%';
```

```
-------------------------------------------------------------------------------------------------------
| Id  | Operation                           | Name            | Rows  | Bytes | Cost (%CPU)| Time     |
-------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                    |                 |     3 |   144 |     7   (0)| 00:00:01 |
|   1 |  TABLE ACCESS BY INDEX ROWID BATCHED| EMP             |     3 |   144 |     7   (0)| 00:00:01 |
|*  2 |   INDEX RANGE SCAN                  | BIRTH_FIRST_IDX |     3 |       |     3   (0)| 00:00:01 |
-------------------------------------------------------------------------------------------------------
```

> 인덱스를 사용해서 정렬 연산 생략이 가능하다.

```sql
CREATE INDEX FIRST_DEPT_IDX ON EMP(FIRST_NAME, DEPT_NO);

SELECT *
FROM EMP
WHERE FIRST_NAME = 'Irene'
ORDER BY DEPT_NO;
```
```
----------------------------------------------------------------------------------------------
| Id  | Operation                   | Name           | Rows  | Bytes | Cost (%CPU)| Time     |
----------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT            |                |   235 | 11280 |   237   (0)| 00:00:01 |
|   1 |  TABLE ACCESS BY INDEX ROWID| EMP            |   235 | 11280 |   237   (0)| 00:00:01 |
|*  2 |   INDEX RANGE SCAN          | FIRST_DEPT_IDX |   235 |       |     3   (0)| 00:00:01 |
----------------------------------------------------------------------------------------------
```

> 조건절이 아닌 SELECT 또는 ORDER BY 절에서 가공해서 Range Scan이 안되는 사례가 존재한다.

쿼리 튜닝 예시를 보겠습니다.

```sql
CREATE INDEX BIRTH_EMP_IDX ON EMP(BIRTH_DATE, EMP_NO);

SELECT *
FROM (
    SELECT 'EM' || LPAD(E.EMP_NO, 7, '0') AS EMP_NO, E.SALARY
    FROM EMP E
    WHERE E.BIRTH_DATE = '1952-12-01'
    ORDER BY EMP_NO
)
WHERE ROWNUM <= 30;
```
```
--------------------------------------------------------------------------------------------------------
| Id  | Operation                              | Name          | Rows  | Bytes | Cost (%CPU)| Time     |
--------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                       |               |    30 |   900 |    68   (2)| 00:00:01 |
|*  1 |  COUNT STOPKEY                         |               |       |       |            |          |
|   2 |   VIEW                                 |               |    63 |  1890 |    68   (2)| 00:00:01 |
|*  3 |    SORT ORDER BY STOPKEY               |               |    63 |  1134 |    68   (2)| 00:00:01 |
|   4 |     TABLE ACCESS BY INDEX ROWID BATCHED| EMP           |    63 |  1134 |    67   (0)| 00:00:01 |
|*  5 |      INDEX RANGE SCAN                  | BIRTH_EMP_IDX |    63 |       |     3   (0)| 00:00:01 |
--------------------------------------------------------------------------------------------------------
```
인덱스 컬럼 순서를 지키고, range scan을 활용한 소트 연산 생략을 기대했지만, SORT가 계획에 나오는 것으로 보아 잘 되지 않는 모습입니다. 왜 그럴까요? 그 이유는 ORDER BY 에서 EMP E의 E.EMP_NO가 아닌 **가공된 컬럼 EMP_NO를 기준으로 정렬** 하기 때문입니다. 가공된 컬럼에 대해서는 우리가 인덱스를 만들어주지 않았기에 당연히 SORT 가 수행됩니다. 아래와 같이 수정하면 됩니다.

```sql
SELECT *
FROM (
    SELECT 'EM' || LPAD(E.EMP_NO, 7, '0') AS EMP_NO, E.SALARY
    FROM EMP E
    WHERE E.BIRTH_DATE = '1952-12-01'
    ORDER BY E.EMP_NO -- 변경
)
WHERE ROWNUM <= 30;
```
```
-----------------------------------------------------------------------------------------------
| Id  | Operation                     | Name          | Rows  | Bytes | Cost (%CPU)| Time     |
-----------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT              |               |    30 |   900 |    34   (0)| 00:00:01 |
|*  1 |  COUNT STOPKEY                |               |       |       |            |          |
|   2 |   VIEW                        |               |    31 |   930 |    34   (0)| 00:00:01 |
|   3 |    TABLE ACCESS BY INDEX ROWID| EMP           |    31 |   558 |    34   (0)| 00:00:01 |
|*  4 |     INDEX RANGE SCAN          | BIRTH_EMP_IDX |    63 |       |     3   (0)| 00:00:01 |
-----------------------------------------------------------------------------------------------
```

또 하나의 쿼리 튜닝을 살펴보겠습니다. 인덱스는 전과 동일합니다.

```sql
CREATE INDEX DEPT_BIRTH_EMP_IDX ON EMP(DEPT_NO, BIRTH_DATE, EMP_NO);

SELECT MIN(EMP_NO)
FROM EMP
WHERE DEPT_NO = 'd005'
AND BIRTH_DATE = '1952-12-01';
```
```
---------------------------------------------------------------------------------------------------
| Id  | Operation                    | Name               | Rows  | Bytes | Cost (%CPU)| Time     |
---------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT             |                    |     1 |    18 |     3   (0)| 00:00:01 |
|   1 |  SORT AGGREGATE              |                    |     1 |    18 |            |          |
|   2 |   FIRST ROW                  |                    |     1 |    18 |     3   (0)| 00:00:01 |
|*  3 |    INDEX RANGE SCAN (MIN/MAX)| DEPT_BIRTH_EMP_IDX |     1 |    18 |     3   (0)| 00:00:01 |
---------------------------------------------------------------------------------------------------
```

MIN, MAX 연산의 실행계획을 보면 FIRST ROW 라는 것이 보입니다. 이는 **딱 한 행만 읽고 종료함**을 의미합니다. 하지만, 조심해야 되는 사례가 있습니다.

```sql
-- FIRST ROW X
SELECT NVL(MIN(TO_NUMBER(EMP_NO)), 0)
FROM EMP
WHERE DEPT_NO = 'd005'
AND BIRTH_DATE = '1952-12-01';

-- FIRST ROW O
SELECT NVL(TO_NUMBER(MIN(EMP_NO)), 0)
FROM EMP
WHERE DEPT_NO = 'd005'
AND BIRTH_DATE = '1952-12-01';
```

둘의 차이는 무엇일까요? 바로 최대/최소를 **TO_NUMBER(EMP_NO) vs EMP_NO** 로 찾는다는 차이가 있습니다. 전자의 경우 이렇게 가공해서 인덱스를 설정한 것이 아니므로 우리가 아는 FIRST ROW 연산이 불가능한 것입니다.

> 자동형변환을 지양하자.

어차피 옵티마이저는 개발자가 형변환함수를 생략해도 자동으로 형변환을 해주기 때문에, 타입이 다르다면 명시적으로 적어주는 습관을 들이는 것이 중요합니다. 그리고 괜히 형변환함수를 안썼다가 컬럼이 가공되는(`Index Range Scan이 되지 않는`) 사례가 충분히 발생하니 조심하는 것이 좋습니다.

### Index Full Scan

Index Range Scan 에서 수직적 탐색을 빼면 Index Full Scan이 됩니다. 즉 필요한 범위만 가져오는 것이 아닌 **리프를 모두 스캔합니다.** 보통 최적의 인덱스가 없을 때 차선으로 선택됩니다.

```sql
CREATE INDEX FIRST_SAL_IDX ON EMP(FIRST_NAME, SALARY);

SELECT *
FROM EMP
WHERE SALARY > 100000
ORDER BY FIRST_NAME;
```

해당하는 경우 선행 컬럼이 첫번째 조건으로 없기 때문에 우선 `FIRST_SAL_IDX`를 전체 스캔하여 정렬된 순서로 리프 노드를 읽습니다. 이후 SALARY 가 100000을 넘는 시작점만 필터링 후 반환합니다.

이미 FISRT_NAME은 인덱스로 정렬이 된 상태이기에 SORT 연산은 생략합니다.

### Index Unique Scan

수직적 탐색만으로 데이터를 찾는 스캔 방식으로 PK와 같은 **Unique 인덱스**를 '=' 조건으로 탐색하는 경우에 작동합니다.

```sql
CREATE UNIQUE INDEX UNIQ_EMP_NO_IDX ON EMP(EMP_NO);

SELECT *
FROM EMP
WHERE EMP_NO = 10000;
```

### Index Skip Scan

선두 컬럼이 조건절에 없다면 기본적으로 Table Full Scan 또는 Index Full Scan을 사용합니다. 하지만 복합 인덱스의 일부 인덱스만 사용하는 방식으로 성능 개선이 가능합니다. 특히, **선두 컬럼의 카디널리티(Distinct Value)가 낮고, 후행 컬럼의 카디널리티(Distinct Value)가 높은 경우** 유용합니다.

- 선두 컬럼이 성별이라면 성별의 카디널리티는 2로 매우 낮습니다. 현재 데이터에 성별은 없지만, 성별이 있다고 가정하면 다음과 같습니다.

```sql
CREATE INDEX GENDER_DEPT_IDX ON EMP(GENDER, DEPT_NO);

-- skip scan은 힌트를 사용하는 것이 일반적
SELECT /*+ INDEX_SS(EMP GENDER_DEPT_IDX) */*
FROM EMP
WHERE DEPT_NO = 'd005';

-- 위 쿼리는 아래 쿼리와 같은 방식으로 실행
SELECT *
FROM EMP
WHERE GENDER = 'F'
AND DEPT_NO = 'd005';
UNION ALL
SELECT *
FROM EMP
WHERE GENDER = 'M'
AND DEPT_NO = 'd005';
```

### Index Fast Full Scan

이름에서 알 수 있듯, 인덱스를 Full Scan 하지만 더 빠릅니다. 더 빠른 이유는 Index는 일반적으로 Single Block I/O지만, Fast Full Scan의 경우 **Multi Block I/O**이기 때문입니다. 그래서 **대량의 데이터**를 들고 올 때 유리하지만, 논리적 순서가 아닌 물리적 저장 위치에 맞게 들고오기에 **순서가 보장되지는 않습니다.** 또한 인덱스가 파티션 되어 있지 않더라도 병렬 쿼리, Direct Path I/O가 가능합니다.

### Index Range Scan Descending

기본적으로 Index Range Scan과 동일하지만 역방향으로 진행해서 결과는 DESC 정렬이 된 상태입니다.