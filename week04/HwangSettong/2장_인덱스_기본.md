# 2장 인덱스 기본

## 2.1 인덱스 구조 및 탐색

<br/>

**인덱스 튜닝 핵심 요소**

1. 인덱스 스캔 효율화 튜닝
2. 랜덤 액세스 최소화 튜닝

* 둘 중 굳이 중요한 걸 고르면 “랜덤 액세스 최소화”

<br/><br/>

**인덱스 구조 (B*Tree)**

```
                         [ Root Block ]
                               |
                    -------------------------
                    |                       |
      [LMC]->[ Branch Block ]         [ Branch Block ]
                 /     \                  /      \
[LMC]->[ Leaf Block ]-[ Leaf Block ]-[ Leaf Block ]-[ Leaf Block ]
            |               |               |              |
      (Key,ROWID) ... (Key,ROWID) ... (Key,ROWID) ... (Key,ROWID)
```

- **Root Block**
    
    탐색 시작 지점. 항상 1개 존재.
    
- **Branch Block (중간 노드)**
    
    키의 범위를 좁혀주는 역할. 
    
    (ex: “100 이하 → 왼쪽 자식” / “101 이상 → 오른쪽 자식”)
    
- **Leaf Block (리프 노드)**
    
    **정렬된 키 값 + ROWID** 저장.
    
    리프 노드끼리는 **양방향 링크(Linked List)** 로 연결되어 있어서 **범위 검색**이 빠름.
    
- **LMC (Leftmost Child)**
    
    항상 **왼쪽 첫 번째 자식 블록**이 LMC
    
    인덱스 Range Scan / Full Index Scan 시 **여기서부터 시작**
    

* B tree 구조에서 루트~리프노드의 높이는 항상 같음


<br/><br/>

**인덱스 탐색**

- 수직적 탐색 : 인덱스 스캔 시작지점을 찾느 ㄴ과정
- 수평적 탐색 : 데이터를 찾는 과정

<br/><br/><br/><br/>

## 2.2 인덱스 기본 사용법

**Index Range Scan 이 불가능한 경우**

1. 조건절에 인덱스의 선두 컬럼이 포함되지 않은 경우
    
    ```sql
    -- 인덱스: (A, B)
    SELECT * FROM table WHERE B = 10 ORDER BY A;
    -- INDEX SKIP SCAN이나 INDEX FULL SCAN으로..
    ```
    
2. 함수나 표현식이 적용된 경우
    
    ```sql
    -- 인덱스: (A, B)
    SELECT * FROM table WHERE SUBSTR(A, 1, 3) = 'abc';
    -- 함수 기반 인덱스로 보완 가능
    ```
    
3. LIKE 조건이 와일드카드(%)로 시작하는 경우
    
    ```sql
    -- 인덱스: (name)
    SELECT * FROM table WHERE name LIKE '%철수';
    ```
    
4. IN 조건이 여러개 걸려 있을 경우
    
    ```sql
    -- 인덱스: (A)
    SELECT * FROM table WHEREA IN (1, 2, 3, ..., 1000);
    ```
    
5. OR 조건이 여러 컬럼에 걸려 있을 경우
    
    ```sql
    -- 인덱스: (A, B)
    SELECT * FROM table WHERE A = 10 OR B = 20;
    ```
    

! IN이나 OR 조건절은 옵티마이저의 쿼리변환 기능을 통해 Index Range Scan으로 처리되기도 함. (UNION ALL 처리)

- 일반적으로, 인덱스를 잘탄다 = Index Range Scan한다.
- 하지만 Index Range Scan을 하고 있어도 리프 블록 스캔량이 많다면 튜닝이 더 필요

<br/><br/>

**소트 생략 (skip sort)**

인덱스는 항상 정렬된 상태. 별도의 소트연산 없이 인덱스 순서대로 결과를 가져올 수 있음

- INDEX RANGE SCAN + ORDER BY 조합에서 발생
    
    ㄴ단, ORDER BY의 컬럼 순서와 인덱스 정의 순서가 정확히 일치해야 하고, 가공하지 않은 상태여야 함.
    
- `MIN`과 `MAX` 함수에서 발생
    
    ㄴ함수에 들어가는 컬럼 값을 가공하지 않은 상태여야 함.
    
    ㄴ 예) `NVL(MAX(TO_NUMBER(변경순번)),0)` X /  `NVL(MAX(변경순번)),0)` O


<br/><br/>

**자동형변환**

날짜형 + 문자형 → 날짜형

숫자형 + 문자형 → 숫자형

decode(a, b, c, b) → c의 type을 따라가고, 만약 c가 null이면 varchar2로 취급

<details>
  <summary>`‘’` 빈문자열</summary>
  
    oracle은 빈문자열을 항상 NULL로 취급.

    즉 Number 타입에 `‘’`를 넣어도 0이 아닌 NULL 로 들어가고, Varchar에도 NULL로 들어가고…
    
    postgres는 이를 엄격하게 금지함 ← 솔루션에서 `‘’`을 NULL 처리하지 않으면 오류 난 이유

</details>    


<br/><br/><br/>

## 2.3 인덱스 확장기능 사용법

**인덱스 스캔 종류**

<img width="631" height="327" alt="image" src="https://github.com/user-attachments/assets/a85826d6-e264-4aa8-b64f-b22f9e97007e" />


| 인덱스 스캔 방식 | 사용 조건 / 특징 | 주 용도 및 장단점 |
| --- | --- | --- |
| **Index Range Scan** | - **선두 컬럼 포함**한 조건<br/>- 범위 조건 (`BETWEEN`, `<`, `LIKE`) 등 | 흔히 사용됨.<br>결과가 여러 건일 수 있음 |
| **Index Full Scan** | - **선두 컬럼 없어도 가능** <br>- `ORDER BY` 등 정렬 목적 <br>- 인덱스가 커도 가능 | 순차 접근이지만 rowid 접근 필요<br>→ 테이블 I/O 발생 |
| **Index Unique Scan** | - **유일 인덱스**<br>- **= 조건**으로 **정확히 하나의 row** 찾을 때 | 가장 빠름.<br>단 하나의 row만 필요할 때만 사용 가능 |
| **Index Skip Scan** | - **선두 컬럼 조건 없음**, **후행 컬럼 조건 존재** <br>- 선두 컬럼 값이 적을수록 효율 | 가능하지만 성능 이슈 발생 가능 |
| **Index Fast Full Scan** | - **정렬 필요 없음.** `ORDER BY` 없음 <br>- multiblock I/O 방식 사용<br>- **인덱스만으로** 원하는 컬럼 조회 시 | 정렬 없이 병렬 가능.<br>테이블 액세스 없이 끝내는 경우에 적합 |
