# Week4

고정하기: No

### 인덱스 튜닝

- 인덱스 스캔 효율화
- 테이블 액세스 최소화

⇒ 테이블 액세스가 성능에 미치는 영향이 더 크기 때문에 더 중요하다. (SQL 튜닝은 랜덤 I/O와의 전쟁이다.)

**LMC :** B-Tree 인덱스 탐색 시, 특정 브랜치에서 조건에 맞는 경로를 따라 내려갈 때 항상 가장 왼쪽의 자식 노드를 선택하는 규칙

Q. 각 루트, 브랜치에 있는 모든 레코드는 하위 브랜치에 대한 주소값을 가지고 있는건가??

→ 그렇다. 그리고 최종적으로 리프 노드(마지막)에 해당하는 레코드를 찾아가는 것이다.(이후 테이블 액세스)

**ROWID** = 데이터 블록 주소 + 로우 번호

**데이터 블록 주소** = 데이터 파일 번호 + 블록 번호

블록 **번호** = 데이터파일 내에서 부여한 상대적 순번

**로우 번호**  = 블록 내 순번

### 수직적 탐색과 수평적 탐색

- **수직적 탐색 :**  인덱스 스캔 시작지점을 찾는 과정
- **수평적 탐색 :**  데이터를 찾는 과정

리프 노드에 실질적인 데이터가 다 있기 때문에 브랜치에서 레코드를 찾아도 리프(하위) 노드로 가야한다. 

**즉, 조건을 만족하는 첫번째 레코드를 찾는 것!**

- 인덱스 리프 블록끼리는 서로 앞뒤 블록에 대한 주소값을 갖는다. (양방향 연결 리스트)

Q. 인덱스만 스캔하고 끝나는 경우도 있지만 인덱스를 스캔하고서 테이블도 액세스 한다. 이때 ROWID가 필요하다?

**인덱스만 보고 끝나는 경우** 

- 인덱스에 쿼리에서 필요한 모든 컬럼이 들어있으면 굳이 테이블까지 가지 않아도 된다.

```sql
SELECT empno
FROM emp
WHERE empno = 1001;
```

- Q. 인덱스만 보고 끝나더라도 데이터를 가져오려면 테이블 액세스가 필요한 것 아닌가?
    - 인덱스는 단순히 검색 Key 값 + ROWID만 가지는 게 아니라, **인덱스를 만들 때 포함된 컬럼 값(리프 노드)**도 리프 노드에 같이 저장된다.

**테이블까지 가야하는 경우**

- 인덱스에 조건 검색 키는 있지만 SELECT에 필요한 컬럼 값이 없을 때, 인덱스에서 ROWID를 얻은 후 실제 데이터 블록까지 가서 데이터를 읽어야 한다.

```sql
SELECT ename, sal
FROM emp
WHERE empno = 1001;
```

- ROWID는 인덱스를 통해 찾은 레코드가 실제 테이블에서 어디 있는지 가리키는 주소

### 1. 인덱스 기본 사용법

**Index Range Scan**  ↔ Index Full Scan

- 리프 블록 일부만 스캔하는 것

**Range Scan을 위한 조건**

1. 선두 컬럼을 가공하지 않아야 한다. 
    - 인덱스를 사용할 수는 있지만, 찾고자 하는 데이터가 전체 구간에 흩어져 있기 때문(불가능 혹은 비효율)
    - 즉, 인덱스 스캔 시작점을 찾을 수 없다.
2. 인덱스 선두 컬럼이 조건절에 있어야 한다. 

<aside>
💡

가공되지 않은 상태로 선두 컬럼에 있어야한다.

</aside>

Exmaple

```sql
CREATE INDEX IDX_사원_소속팀_사원번호_연령
ON 사원 (소속팀, 사원번호, 연령);

SELECT 사원번호, 소속팀, 연령, 입사일자, 전화번호
FROM 사원
WHERE 사원명 = '홍길동'
```

![image.png](Week4%202550294679ba80e9a59ef5eb8248aa27/image.png)

**Quiz**. 인덱스 탐색 과정을 수평적 탐색, 수직적 탐색을 사용해서 설명해보시오.

**Or Expansion** 

```sql
select *
  from emp
 where ename = :ename
 union all
select *
  from emp
 where job = :job
   and (mgr <> :mgr or deptno is null);
```

![image.png](Week4%202550294679ba80e9a59ef5eb8248aa27/image%201.png)

OR 조건절 대신 UNION ALL을 사용하여 Index Range Scan이 가능하다.

### 2. 인덱스 소트 연산 생략

인덱스를 사용하면 데이터가 정렬된 상태이기 때문에 인덱스를 활용해 Sort연산을 생략할 수 있다. 

**Example**

- 내림차순인 경우에도 Sort 연산은 생략된다.
    
    ⇒ Index Range Scan 단게에서 DESCENDING으로 우측에서 왼쪽으로 수평적 탐색이 가능.
    

```sql
CREATE INDEX emp_empno_ename_idx
ON emp (empno, ename);

SELECT *
  FROM EMP
 WHERE EMPNO = 123
 ORDER BY ENAME DESC;
```

![image.png](Week4%202550294679ba80e9a59ef5eb8248aa27/image%202.png)

⇒  내부적으로 역순 스캔을 하면서도 실행계획에는 DESCENDING이라고 안 찍힐수도 있나보다..

**ORDER BY, SELECT-LIST :  컬럼을 가공하여 인덱스 정상 사용 안되는 경우** 

**ORDER BY**

```sql
SELECT *
  FROM EMP
 WHERE EMPNO = 123
 ORDER BY ENAME || DEPTNO;
```

⇒ ENAME과 DEPTNO를 합쳐서 가공하여 사용하면 인덱스를 정상적으로 사용할 수 없다.

```sql
SELECT TO_CHAR(E.DEPNO, 'FM00000')
  FROM EMP E
 WHERE E.EMPNO = 123
 ORDER BY DEPTNO;
 => ORDER BY E.DEPTNO
```

⇒ **DEPTNO**는 순수한 **DEPTNO**가 아닌 가공된 **DEPTNO**를 가리키기 때문에 X

- Alias를 명시해줘야한다.

**SELECT-LIST**

MIN/MAX

```sql
SELECT MIN(ENAME)
FROM EMP
WHERE EMPNO = '123';

SELECT MAX(ENAME)
FROM EMP
WHERE EMPNO = '123';
```

![image.png](Week4%202550294679ba80e9a59ef5eb8248aa27/image%203.png)

⇒ 인덱스를 이용해 이처럼 정렬 연산 없이 최소, 최대값을 빠르게 찾을 수 있다. 

**조회 컬럼 가공 예시**

```sql
SELECT NVL(MAX(TO_NUMBER(DEPTNO)), 0)
FROM EMP
WHERE EMPNO = '123'
  AND ENAME = '진용민';
```

![image.png](Week4%202550294679ba80e9a59ef5eb8248aa27/image%204.png)

⇒ 단, 이처럼 바꾼 값 기준으로 요구하게 되면 사용할 수 없다. 

**수정방안**

```sql
SELECT NVL(TO_NUMBER(MAX(DEPTNO)), 0)
FROM EMP
WHERE EMPNO = '123'
  AND ENAME = '진용민';
```

![image.png](Week4%202550294679ba80e9a59ef5eb8248aa27/image%205.png)

⇒ MIN/MAX가 실행계획에 출력되며 쉽게 찾을 수 있다.

(추가)조회 컬럼의 값을 서브쿼리를 사용해서 최소, 최대값을 사용한다고해도 정렬연산없이 찾을 수 있다.

**결론은 인덱스 컬럼을 가공하는 것에 대해서 신중하게 고려해야한다.**

**자동 형변환**

일반적으로 숫자형과 문자형이 만나면 숫자형이 이긴다.

```sql
 SELECT * FROM 고객
	 WHERE 생년월일 = 19811225
	 
=> TO_NUMBER로 형변환되며, FULL SCAN을 하게 된다. 
```

하지만 연산자가 LIKE일 때는 문자열 비교 연산이기 때문에 숫자형 컬럼이 문자형으로 변환된다. 

```sql
 SELECT * FROM 고객
	 WHERE 고객번호 = '9810%'
=> TO_CHAR로 형변환
```

**자동 형변환에 의존하지 말고 개발자가 직접 형변환하여 비효율적인 쿼리 실행을 방지해야한다.** 

### Index Full Scan vs. Table Full Scan

Index Full Scan : 찾아야 할 데이터의 수가 적을 때 

- 단, 이것도 Index Range Scan의 차선책

Table Full Scan : 찾아야 할 데이터의 수가 많을 떄

⇒ 랜덤 I/O인 Index Full Scan과 다르게 Sequential I/O이기 때문이다.

**Index Unique Scan** : Unique 인덱스를 “=”로 탐색할 경우

**Index Skip Scan :** 특정 Range만을 탐색하는 Scan 방식

- 인덱스의 선두 컬럼이 조건절에 없는 경우
- 인덱스의 선두 컬럼 distinct 값이 적을 경우